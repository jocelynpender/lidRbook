```{r,echo=FALSE,message=FALSE,warning=FALSE}
r3dDefaults = rgl::r3dDefaults
m = structure(c(0.921, -0.146, 0.362, 0, 0.386, 0.482, -0.787, 0, 
-0.06, 0.864, 0.5, 0, 0, 0, 0, 1), .Dim = c(4L, 4L))
rgl::setupKnitr()
r3dDefaults$FOV = 50
r3dDefaults$userMatrix = m
r3dDefaults$zoom = 0.75

knitr::opts_chunk$set(
  comment =  "#>", 
  collapse = TRUE,
  fig.width = 4,
  fig.height = 3,
  fig.align = "center")

library(lidR)
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
las <- readLAS(LASfile)
```

`lidR` is designed to process LAS files for several technical reasons including the fact it is a format backed by a public format specifications, it is a binary format providing and efficient storage in read and write mode and it contains a header that describes in depth the content of the file including its bouding box. The compress version (LAZ format) is also supported.

# Reading, Plotting, Querying & Validating

## Reading lidar data using `readLAS`

The function `readLAS()` reads a LAS or LAZ files and returns an object of class `LAS`. The `LAS` formal class is documented in depth in a [dedicated vignette](https://cran.r-project.org/web/packages/lidR/vignettes/lidR-LAS-class.html).

```r
las <- readLAS("files.las")
```

When printed it displays a summary of its content in a similar way to the `sp` package.

```{r}
print(las)
```

For a more in-depth print of the data one can use the function `summary()` instead of `print()`.

### Parameter `select`

A LAS file stores the X Y Z coordinates of each point as well as many other data for each point such as the intensity, the incidence angle, the position of the point in the return sequence and so on. We called these data: *attributes*. In pratice many attributes are not actually useful but they are loaded anyway by default and this take a lot of processing memory because R is a language that does not allows for data chosing storage modes (the the vignette for more details).

To save memory, `readLAS` can take an optional parameter `select` which enables the user to selectively load the attributes of interest. For example, one can choose to only load only the `X Y Z` fields.

```r
las <- readLAS("file.las", select = "xyz")  # load XYZ only
las <- readLAS("file.las", select = "xyzi") # load XYZ and intensity only
```

### Parameter `filter`

While `select` enables the user to select "columns" (or attributes) while reading files, `filter` allows selection of "rows" (or points) while reading. Removing data at reading time that is superfluous for your purposes saves memory and decreases computation time. It is a common pratice in forestry to process only first returns for example.

```r
las <- readLAS("file.las", filter = "-keep_first") # Read only first returns
```

It is important to understand that the option `filter` in `readLAS()` keeps or discards point **at read time** i.e. while reading at the C++ level independently of R. Some users have already reported missunderstanding of the behavior of this options because it is different form other `filter` users may encounter in other functions and that work at the R level. For exemple the R function to filter points of interest (POI) is `filter_poi()`. In the following example we are (1) reading only the first returns and (2) reading all the points then filtering the first return.


```r
las <- readLAS("file.las", filter = "-keep_first")

las <- readLAS("file.las", filter = "-keep_first")
las <- filter_poi(las, ReturnNumber == 1L)
```

Both outputs are strictly identical but the first one is faster and more memory efficient. We will also see that it is the only way to load only some POI in some cases in the chapter about `LAScatalog`.

Several filter commands can be associated. The full list of avaible commands is given by `rlas::lasfilterusage()`.

```r
las <-  readLAS("file.las", filter = "-keep_first -drop_z_below 5 -drop_z_above 50")
```

## Plotting

The `lidR` package takes advantage of the `rgl` package to provide a versatile and interactive 3D viewer with point colored by default by their Z coordinates and displayed on a black background. Being based on `rgl` this viewer is extremely versatile but it also uses a lot of memory and has difficulties at displaying too big point clouds.

### Basic plots

The very basic way to render a point cloud is the function `plot()`.


```{r, rgl = TRUE}
plot(las)
```

Users can change the attributes used for coloring by providing the name of the attribute used to colorize the points. The background color of the viewer can also be changed by inputing a color into the `bg` parameter. Axis can also be added and point size can be changed.

```{r, rgl = TRUE}
# Plot las object by return number, make the background grey, and display XYZ axis
plot(las, color = "ScanAngleRank", bg = "white", axis = TRUE, legend = TRUE)
```

Note that if your file contains RGB data the string `"RGB"` is supported:

```r
plot(las, color ="RGB")
```

The `trim` parameter enables trimming of values when outliers break the color palette range. For example, Intensity often contains large outliers. The palette range would be too large and most of the values will be considered as "very low", so everything will appear in the same color.

```{r, rgl = TRUE}
plot(las, color = "Intensity", trim = 50, bg = "white")
```

### Advanced plots

In the previous section we have seen how to display a single point cloud and nothing else. This section shows how to make more advanced rendering overprinting additionnal objects. Being based on `rgl` it is easy to add objects in the main redering. However `lidR` introduced a difficulty because it does not displays the points with their actual coordinates. Usually ALS data XY coordinates are accurate big numbers such as `58130112.282` and because `rgl` uses `float` (decimal numbers on 32 bitS) instead of `double` (decimal numbers on 64 bits) the accuracy is lost and the rendering may look ugly and wrong. This is why the points are shifted to be rendered close to (0, 0). When `plot()` is used it returns invisibly the shift values that can be used later to realign other objects.

```{r}
offsets = plot(las)
print(offsets)
```
`lidR` provides some easy to use functions for common overlay. For example `add_dtm3d()` to add a digital terrain model (see dedicated section) adn `add_treetops3d()` to visualize the output of an individual tree detection (see dedicated section)

```{r, echo = FALSE}
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las <- readLAS(LASfile, select = "xyzc")
dtm <- grid_terrain(las, 2, tin())
las <- clip_disc(las, 273516, 5274496, 80)
```

```{r, rgl = TRUE}
x = plot(las, bg = "white", size = 3)
add_dtm3d(x, dtm)
```

```{r, echo = FALSE}
LASfile <- system.file("extdata", "MixedConifer.laz", package="lidR")
las <- readLAS(LASfile, select = "xyzc")

ttops <- find_trees(las, lmf(ws = 5))
```

```{r, rgl = TRUE}
x = plot(las, bg = "white", size = 3)
add_treetops3d(x, ttops)
```

It is also possible to combine two point cloud with e.g. different color palettes. In the following example were are using an already classified cloud. We first separate the vegetation and non vegetation points using `filter_poi()` and then plot both on each other with different color scheme using `add` options in `plot()`

```{r, echo = FALSE}
r3dDefaults$zoom = 0.3
las = readLAS("data/chap11/building_WilliamsAZ_Urban_normalized.laz", filter = "-thin_random_fraction 0.4")
```

```{r, rgl = TRUE, fig.width=8}
nonveg = filter_poi(las, Classification != LASHIGHVEGETATION)
veg = filter_poi(las, Classification == LASHIGHVEGETATION)

x = plot(nonveg, color = "Classification", bg = "white", size = 3)
plot(veg, add = x)
```


## Validating lidar data

An important first step in lidar data processing is ensuring that your data is complete and valid. Users commonly report bugs about their point cloud being invalid. This is why we introduced the `las_check()` function to perform a deep inspection of `LAS` objects. This function checks if a `LAS` object meets specifications and whether it is invalid for processing. 

A simple example that happens fairly often is that a `LAS` file contains duplicate points. This may lead to trees being detected twice, to invalid metrics, or to errors in DTM generation, and so on. We can also encounter invalid return number, incoherant return number and number of returns attributes, invalid coordinate reference system an many other case. Always make sure to run the `las_check()` function before digging deep into your data.

```{r}
las_check(las)
```

A check is performed at read time anyway. But the read time check does not go as deep as `las_check()` for computation time reasons. For example duplicated points are not checked at read time.

```{r, warning = TRUE}
las = readLAS("data/chap1/corrupted.laz")
```

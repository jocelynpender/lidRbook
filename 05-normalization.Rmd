```{r vis_startup,echo=FALSE,message=FALSE,warning=FALSE}
r3dDefaults = rgl::r3dDefaults
m = structure(c(0.921, -0.146, 0.362, 0, 0.386, 0.482, -0.787, 0, 
-0.06, 0.864, 0.5, 0, 0, 0, 0, 1), .Dim = c(4L, 4L))
rgl::setupKnitr()
r3dDefaults$FOV = 50
r3dDefaults$userMatrix = m
r3dDefaults$zoom = 0.75
library(lidR)
```

# Height normalization

The purpose of the DTM, apart from using it as a stand alone product, is to facilitate terrain normalization. 

Described simply, point cloud normalization removes the influence of terrain on above ground measurements. This makes comparison of above ground vegetation heights possible and simplifies analyses accross acquisition areas.

Two normalization approaches are most commonly used (both are implemented within `lidR`):

* Subtract the derived raster DTM elevation from all non-ground returns 
* Interpolate ground points directly and subtract beneath the non-ground returns

`lidR` can implement both methods, and has three implemented algorithms that can perform this method of point cloud normalization:

* `knnidw` - Interpolation is done using a k-nearest neighbour (KNN) approach with an inverse distance weighting (IDW). This is a fast but basic method for spatial data interpolation.

* `delauney` - Interpolation based on Delaunay triangulation. It makes a linear interpolation within each triangle. Note that with this method no extrapolation is done outside of the convex hull determined by the ground points.

* `kriging` - Interpolation is done by universal kriging using the krige function. This method combines the KNN approach with the kriging approach. For each point of interest it kriges the terrain using the k-nearest neighbour ground points. This method is more difficult to manipulate but it is also the most advanced method for interpolating spatial data.

__When using the `knnidw` and `kriging` methods, the user must specify the number of nearest neighbours (parameter `k`) that the algorithm should use for interpolation.__ MAYBE REMOVE THIS?

As before we need to read in our lidar data

```{r, rgl=TRUE}
# Read Topography.laz from within the lidar package
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las <- readLAS(LASfile)
plot(las, size = 3)
```

We can see in the image that these data are not normalized as the slope of the terrain is still visible. To get a better idea of what the terrain looks like lets remove all non-ground points.

```{r, rgl = TRUE}
las_grnd <- lasfilter(las, Classification == 2L)
plot(las_grnd, size = 3)
```

We can ensure that these points are ground points by colorizing the points based on classification. We should only see 1 colour.


```{r, rgl = TRUE}
plot(las_grnd, color = "Classification", size = 3)
```

## DTM normalization

To normalize points using a DTM we first need to create the DTM itself. For this we use the `grid_terrain()` function. We have chosen to use a grid resolution of 1 m and to use the `knnidw()` algorithm with default parameters.

```{r, fig.height=5.85, fig.width=6}
# Compute a 1m reoslution DTM
dtm = grid_terrain(las, 1, knnidw())
# Note that dtm is a RasterLayer
class(dtm)
# Plot the DTM raster to visualize elevation changes
plot(dtm, col = gray.colors(50, 0, 1))
```

`lidR` also allows us to visualize rasterized DTM layers in 3d using the `plot_dtm3d()` function

```{r,rgl = TRUE}
plot_dtm3d(dtm)
```

We are also able to combine the DTM surface with the lidar plot layer using `adddtm3d()` function

```{r,rgl = TRUE, echo = FALSE}
x <- plot(las, size = 3)
add_dtm3d(x, dtm)
```

We can see that the DTM surface matches very well with the ground points - which it should!

Now that we have our surface and are satisfied with it we can use it to normalize our pointcloud using the `lasnormalize` function.

```{r, rgl = TRUE}
nlas <- lasnormalize(las,dtm)
plot(nlas, size = 3)
```

We can see that the ground points of the point cloud have been normalized, making the point cloud appeach much flatter. All above ground vegetation are now comparable.

## Point cloud normalization

Point cloud normalization without a DTM  utilises all returns, where ground points are interpolated to the exact position beneath non-ground points.

```{r, rgl = TRUE}
nlas = lasnormalize(las, knnidw())
#nlas = lasnormalize(las, kriging())
#nlas = lasnormalize(las, delauney())
plot(nlas, size = 3)
```

## Reversing normalization

`lidR` also has the capacity to reverse normalization using the `lasunnormalize` function. This reverts the normalized point cloud to its pre-normalized state.

```{r,eval=F}
las <- lasunnormalize(las)
```


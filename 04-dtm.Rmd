```{r,echo=FALSE,message=FALSE,warning=FALSE}
library(lidR)
library(ggplot2)
library(rgl)
library(forcats)

source("function_plot_crossection.R")

r3dDefaults = rgl::r3dDefaults
m = structure(c(0.921, -0.146, 0.362, 0, 0.386, 0.482, -0.787, 0, 
-0.06, 0.864, 0.5, 0, 0, 0, 0, 1), .Dim = c(4L, 4L))
rgl::setupKnitr()
r3dDefaults$FOV = 50
r3dDefaults$userMatrix = m
r3dDefaults$zoom = 0.75

knitr::opts_chunk$set(
  comment =  "#>", 
  collapse = TRUE,
  fig.align = "center")
```

# Digital terrain model {#dtm}

Generating a Digital Terrain Model (DTM) usually follows the classification of ground points (see section \@ref(gnd)) as the second step of point cloud data analyses. Put simply, a DTM can be described as an "image" of the ground. Over the past decades, methods to generate DTMs have been intensively studied and several algorithms have been proposed for various terrain situations. DTMs are used for a variety of purposes in practice, such as determination of the catchment basins of water retention and stream flow, or the identification of drivable roads to access resources. It also enables users to normalize the point cloud i.e. subtract the local terrain from the elevation of points to allow a manipulation of point clouds as if they were acquired on a flat surface (see section \@ref(normalization)).

The construction of a DTM is simply a spatial interpolation of the ground points at unsampled locations. The accuracy of the DTM is very important since errors in the DTM will result in errors of tree height estimation, or more generally in inaccuracies in the measurement of the relative height of any given point relatively to the ground. There is a wide range of methods that can be used to make spatial interpolation of points, which result from decades of research in mathematics and algorithmic sciences. All such methods are applicable to ALS data. In the following chapter we will use the dataset provided with the package as example already classified:

```{r, rgl = TRUE}
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las = readLAS(LASfile, filter = "-keep_class 2")
plot(las, size = 4, bg = "white")
```


## Triangular irregular network (TIN)

This method is based on triangular irregular of the ground point data to derive a bivariate function for each triangle, which is then used to estimate the values at unsampled locations (between the ground points). 

```{r, rgl = TRUE, echo = FALSE}
dxyz <- with(las@data, deldir::deldir(X, Y, z = Z, suppressMsge = TRUE))
col <- with(las@data, height.colors(20)[1 + round(19*(Z - min(Z))/diff(range(Z)))])
rgl::persp3d(dxyz, col = col, smooth = FALSE, add = T, front="lines", axes = F)
rgl::axes3d(c("x-", "y+", "z-"))
rgl::grid3d(side=c('x-', 'y+', 'z-'), col="gray")
```

Linear interpolation uses planar facets of each triangle to create the interpolation. Used with a Delaunay triangulation, this is the most simple and trivial solution because it involves no parameters. Indeed, the Delaunay triangulation is unique and the linear interpolation is parameter-free. The drawbacks of the method are that it creates a non-smooth DTM and that it cannot extrapolate the terrain outside the convex hull delimited by the ground points since there is no triangle facets outside the convex hull. Moreover the interpolation is weak at the edges because of large irrelevant triangles often created. Thus is it is important to compute the triangulation with a buffer to be able to crop the DTM and clear the edge artifacts.

To generate a DTM model with the TIN algorithm we use `grid_terrain()`  with the `tin()` algorithm:

```{r, rgl = TRUE}
dtm_tin = grid_terrain(las, res = 1, algorithm = tin())
plot_dtm3d(dtm_tin, bg = "white") 
```

One can easily notice some ungly edge interpolation inherant to the method when computed without buffer.

## Invert distance weighting (IDW)

Invert distance weighting (IDW) is one of the simplest and most readily available methods that can be applied to create DTM. It is based on an assumption that the value at an unsampled point can be approximated as a weighted average of values at points within a certain cut-off distance d, or from a given number k of closest neighbours. Weights are usually inversely proportional to a power p of the distance between the location and the neighbour, which leads to the computing of an estimator. Compared to `tin()` this method is more robust to edge artifact because it uses a more relevant neighrood but generate terrains that are "bumpy" and probably not as realistic as in triagulation.

To generate a DTM model with the IDW algorithm we use `grid_terrain()`  with the `knnidw()` algorithm:

```{r, rgl = TRUE}
dtm_idw = grid_terrain(las, algorithm = knnidw(k = 10L, p = 2))
plot_dtm3d(dtm_idw, bg = "white") 
```

One can easily notice the bumpy nature of the DTM inherant to the method compared to the previous one generated with `tin()`. This comes for the mathematics that drive the method. In 1D and IDW interpolation looks like:

```{r, echo = FALSE, fig.height=2, fig.width=6}
set.seed(43)
x = runif(20, 0, 20)
z = 2*sin(x)+2
y = rep(0, 20)

X = seq(0,20,0.1)
Y = rep(201, 0)

Z = lidR:::C_knnidw(x,y,z, X, Y, 7, 2, 100, 1)

opar = par(mar = c(0,0,0,0))
plot(x,z, asp = 1, xlab = "", ylab = "", xaxt='n', yaxt = "n", ann=FALSE)
lines(X,Z)
par(opar)
```

## Kriging

Kriging is the most advanced approach and utilises advanced geostatistical interpolation methods that take into account the relationships between the returns and their respective distances from each other. `lidR` uses the package `gstat` to perform the kriging. This method is very advanced, difficult to manipulate, extremely slow to compute but probably provides the best results with the mininal edge artifact.


```{r, message=F, warning=F, rgl = TRUE}
dtm_kriging = grid_terrain(las, algorithm = kriging(k = 40))
plot_dtm3d(dtm_kriging, bg = "white") 
```

We can also see it is very weak at interpolating regions with missing point such as lakes.

## Pros and cons

- **Triangulation** is a very fast and efficient methods that generate very good terrains and the is robust to empty regions inside the point cloud. However it is weak at the edges. `lidR` uses the neareast neighbour to complete the missing pixel out of the convex hull of the ground points so there is no missing pixel but yet, the interpolation is poor. It must alway be used with a buffer of extra points to ensure that the region of interest does not belong on the edges. It is the recommended method from broad DTM compuation but should be avoided for small region of interest loaded without buffer.
- **Invert distance weighting** is fast but approximatively twice slower than TIN. The terrain is not very realistic but edges are likely to be free of strong edge artifacts. It is a compromise between TIN and KRIGING. It is recommended if you want a simple method, if you cannot load a buffer and if the edges are important.
- **Kriging** is very slow because it is computanionnaly demanding. It does not worth it to try to use it on medium to large areas. It can be used for small plots without buffer to get a nice DTM without strong edges artifact.

Whatever the method used, edges are critical. Asking a method to interpolate at the edges is trying to guess the local topography with only a partial information on the neighborhood. It will always be weak. Different methods provide more or less good guesses. The best is **always** to use a buffer to obtain some information about the neighborhood no matter the method and remove the buffer once the terrain is computed.

## Other methods

Spatial interpolation is not limited to the 3 methods described here and implemented in `lidR`. Many more were describe in the litterature. In section \@ref(plugins) will learn how to create an plugin algorithm compatible with `grid_terrain()` based on a multilevel B-spline approximation (MBA) using the [`MBA`](https://cran.r-project.org/web/packages/MBA/index.html) package.

```{r, echo = FALSE}
mba <- function(n = 1, m = 1, h = 8, extend = TRUE)
{
  f <- function(what, where, scales = c(0,0), offsets = c(0,0)) {
    res <- MBA::mba.points(what, where, n, m , h, extend)
    return(res$xyz.est[,3])
  }
  class(f) <- lidR:::LIDRALGORITHMSPI
  return(f)
}
```

```{r, rgl = TRUE}
dtm_mba = grid_terrain(las, algorithm = mba())
plot_dtm3d(dtm_mba, bg = "white")
```

## Render shaded DTM

Generating a hillshade layer in R is relatively straighforward and is done using function from the `raster` package. These two function: `terrain()` and `hillShade()` can be combined into a single function that will take the DTM raster layers as input and return a hillshade raster:

```{r, fig.height=5.85, fig.width=6}
dtm_tin = crop(dtm_tin, extent(dtm_tin) - 3) # Remove 3 m of buffer

dtm_prod <- terrain(dtm_tin, opt = c("slope", "aspect"))
dtm_tin_hillshade <- hillShade(slope = dtm_prod$slope, aspect = dtm_prod$aspect)
plot(dtm_tin_hillshade, col = grey.colors(50, 0, 1), legend = FALSE)
```


The [`rayshader`](https://github.com/tylermorganwall/rayshader) package also provides interesting tools to generate shaded DTM.

```{r, rgl = TRUE}
library(rayshader)
elmat <- raster_to_matrix(dtm_tin)
map <- elmat %>%
  sphere_shade(texture = "imhof1") %>%
  add_water(detect_water(elmat), color = "imhof1") %>%
  add_shadow(ray_shade(elmat), 0.5) %>%
  add_shadow(ambient_shade(elmat), 0)
```

2D plot

```{r}
plot_map(map)
```

3D plot

```{r, rgl = TRUE, warning  = FALSE, fig.height=15}
plot_3d(map, elmat, zscale = 1, windowsize = c(800, 800))
```


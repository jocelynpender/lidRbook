```{r vis_startup,echo=FALSE,message=FALSE,warning=FALSE}
library(lidR)
library(ggplot2)
library(rgl)
library(forcats)

r3dDefaults = rgl::r3dDefaults
m = structure(c(0.921, -0.146, 0.362, 0, 0.386, 0.482, -0.787, 0, 
-0.06, 0.864, 0.5, 0, 0, 0, 0, 1), .Dim = c(4L, 4L))
rgl::setupKnitr()
r3dDefaults$FOV = 50
r3dDefaults$userMatrix = m
r3dDefaults$zoom = 0.75

```

# Digital terrain model 

Generating a Digital Terrain Model (DTM) usually follows the classification of ground points as the second step of point cloud data analyses. Put simply, a DTM can be described as an “image” of the ground. Over the past decades, methods to generate DTMs have been intensively studied and several algorithms have been proposed for various terrain situations. DTMs are used for a variety of purposes in practice, such as determination of the catchment basins of water retention and stream flow, or the identification of drivable roads to access resources. It also enables users to normalize the point cloud i.e. subtract the local terrain from the elevation of points to allow a manipulation of point clouds as if they were acquired on a flat surface.

The construction of a DTM is simply a spatial interpolation of the ground points at unsampled locations. The accuracy of the DTM is very important since errors in the DTM will result in errors of tree height estimation, or more generally in inaccuracies in the measurement of the relative height of any given point relatively to the ground.

There is a wide range of methods that can be used to make spatial interpolation of points, which result from decades of research in mathematics and algorithmic sciences. All such methods are applicable to ALS data but they vary in difficulty of use and they are not necessarily available in dedicated software. Below we present three interpolation methods that are implremented in the `lidR` package and can be used to create a DTM. 


## Triangular irregular network (TIN)

This method is based on triangular tessellation of the ground point data to derive a bivariate function for each triangle, which is then used to estimate the values at unsampled locations (between the ground points). A first source of variation in the DTM comes from the several ways in which such triangulation can be computed. Yet, as seen in figure XXX, no interpolation has been performed at this stage. The ground points have been meshed but there is no new data at unsampled locations. Hence, a second source of variation in the DTM comes from the several interpolation options that can be applied. When describing a method used to derive a DTM two pieces of information are therefore required (approach used to perfomr triangulation and interpolation).

<center>

![](images/DTM/TINDTM.svg)

</center>

Linear interpolation uses planar facets of each triangle to create the interpolation. Used with a Delaunay triangulation, this is the most simple and trivial solution because it involves no parameters. Indeed, the Delaunay triangulation is unique and the linear interpolation is parameter-free. The drawbacks of the method are that it creates a non-smooth DTM and that it cannot extrapolate the terrain outside the convex hull delimited by the ground points since there is no triangle facets outside the convex hull.

Non-linear functions use additional continuity conditions in first-order, or both first- and second-order derivatives, thus ensuring a smooth connection of triangles as well as the differentiability of the resulting surface. The drawback is that it involves a more complex parametrization of the algorithm with possibly several non-trivial parameters to choose. There are many ways to fit non-linear functions and to choose parameters. 

The spatial interpolation implemented in `lidR` is based on a Delaunay triangulation, which performs a linear interpolation within each triangle. For areas outside the convex hull determined by the ground points (edge of the dataset), extrapolation is performed using the nearest neighbour approach.

To perfom ground interpolation in `lidR` the `grid_terrain()` function is used with parameters specifying the interpolation method. Example below demonstrates ground interpolation using the TIN approach.

The example will be based on the `Topography.laz` datasets included in the `lidR` package. The point cloud was already classified and contains points classified as "ground".

```{r}
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las <- readLAS(LASfile)
```

To generate a DTM model with the TIN algorithm, we use the `grid_terrain()` as follows:
```{r}
dtm_tin = grid_terrain(las, res = 1, algorithm = tin())
```

The output (`dtm_tin`) is a raster (object of class `RasterLayer`) that can be visualized with the `plot()` function.
```{r}
plot(dtm_tin)
```
```{r, rgl = TRUE}
plot_dtm3d(dtm_tin) 
```

## KNNIDW

Invertse distance weighting (IDW) is one of the simplest and most readily available methods that can be applied to create DTM. It is based on an assumption that the value at an unsampled point can be approximated as a weighted average of values at points within a certain cut-off distance d , or from a given number k of closest neighbours (Mitas and Mitasova, 1999). Weights are usually inversely proportional to a power p of the distance between the location and the neighbour, which leads to the computing of an estimator.

Therefore, the method can be summarized by the definition of two easily explainable parameters (i.e. k or d). While this basic method is easy to implement and available in almost any geographic information system (GIS), it has some well-known shortcomings that limit its practical applications. The method often does not reproduce the local shape evidenced by the data and it produces noticeable artefacts, such as local extrema at the location of the data points.

But more important, while a Delaunay triangulation with linear interpolation provides a unique DTM, IDW algorithms can return many different DTMs depending on the neighbourhood definition and the chosen power function p (see fig. 6). Thus, stating that the DTM was interpolated using an IDW without stating how the neighbourhood was defined and how the weights were computed is not much better than a complete absence of information. 






`knnidw()` description here

```{r}
dtm_idw = grid_terrain(las, algorithm = knnidw(k = 6L, p = 2))
```


```{r}
plot(dtm_idw)
```


```{r, rgl = TRUE}
plot_dtm3d(dtm_idw) 
```

## Kriging

Kriging is the most advanced approach and utilises advanced geostatistical interpolation methods that take into account the relationships between the returns and their respective distances from each other (Oliver and Webster, 1990). In lidR a universal kriging method is used that is implemented in the package gstat (Gräler et al., 2016). This allows the user to have a full control of the underling variogram model and the parameters. Users can specify which model type is used in the variogram, with the spherical model used by default. Users can also modify the number of k-nearest neighbours used in the interpolation (default = 10).



```{r, message=F, warning=F}
dtm_kriging = grid_terrain(las, algorithm = kriging())
```

```{r, rgl = TRUE}
plot_dtm3d(dtm_kriging) 
```



## Comparing interpolation methods

To compare the three ground surface interpolation methods we will use two separate visualization methods. First a hillshade will be create for each surface, which will highlight the similarities and differences between the DTMs. Second, a side view of each DTM will be plotted on crossection.

Generating a hillshade layer in R is relatively straighforward and is done using function from the 'raster' package. These two function: 'terrain()' and 'hillShade()' can be combined into a single function that will take the DTM raster layers as input and return a hillshade raster:

```{r}

#function to generate a hillshade (combines two functions from the reaster package)
make_hillshade <- function(dtm) {
  dtm_prod <- terrain(dtm, opt=c("slope", "aspect"))
  return(hillShade(slope = dtm_prod$slope, aspect = dtm_prod$aspect))
}


```

We can then use this function to generate three hillshade rasters, one for each of the DTMs:

```{r}
dtm_tin_hillshade <- make_hillshade(dtm_tin)
dtm_idw_hillshade <- make_hillshade(dtm_idw)
dtm_krigin_hillshade <- make_hillshade(dtm_kriging)

```

The hillshade layers can be visualized as follows:

```{r}
par(mfrow=c(1,3)) #defining the number of panel in the plot

plot(dtm_tin_hillshade, col=grey(0:100/100), legend=FALSE, main='TIN')
plot(dtm_idw_hillshade, col=grey(0:100/100), legend=FALSE, main='KNNIDW')
plot(dtm_krigin_hillshade, col=grey(0:100/100), legend=FALSE, main='Kriging')
```



To assess the interpolation result on a crossection the DTM layers need to be cropped to the extent of the crossection line - in this case the crossection will be 50 m long, and 1 m wide. The beginning and end of the crossection are defined with two variables: 'p1' and 'p2':

```{r}
p1 = c(273420, 5274455)
p2 = c(273570, 5274456)
```

Each DTM can then be cropped using 'p1' and 'p2' to define the extent of the subset:

```{r}
dtm_tin_crop <- crop(dtm_tin,extent(p1[1],p2[1],p1[2],p2[2]))
```

For visualization purposes it is easier to convert the 'RasterLayer' object returned by the 'crop()' function to a 'data.frame'. To preserve the coordinates 'xy' argument needs to be set to 'TRUE'

```{r}
dtm_tin_crop <- as.data.frame(dtm_tin_crop, xy=T)
```

To distinguish between the different DTMs an additional attribute is added. This attribute ('type') allows to identify the source raster of each value in the data frame and is crucial in the following steps.
```{r}
dtm_tin_crop$type <- "TIN"
```


When converted to a 'data.frame' the cropped layer has a following structure
```{r}
head(dtm_tin_crop)
```

The whole operation can be then repeated for the two remaining DTMs:

```{r}
dtm_idw_crop <- crop(dtm_idw,extent(p1[1],p2[1],p1[2],p2[2]))
dtm_idw_crop <- as.data.frame(dtm_idw_crop, xy=T)
dtm_idw_crop$type <- "IDW"

dtm_kriging_crop <- crop(dtm_kriging,extent(p1[1],p2[1],p1[2],p2[2]))
dtm_kriging_crop <- as.data.frame(dtm_kriging_crop, xy=T)
dtm_kriging_crop$type <- "Kriging"
```

The three data frames are combined into one. The 'type' attribute is converted to a factor with levels kept in order in which they appear in the data:

```{r}
dtm_crop <- rbind(dtm_tin_crop, dtm_idw_crop, dtm_kriging_crop)
dtm_crop$type <- fct_inorder(dtm_crop$type)
```

In addition to the interpolated elevations the point cloud will be plotted as well.
```{r}
las_clipped <- clip_transect(las, p1, p2, width = 1)
```



Finally the plot is created

```{r}
ggplot(data=dtm_crop, aes(x, Z)) + 
  geom_line() +
  geom_point(data=las_clipped@data, aes(X,Z, color=factor(Classification))) + 
  coord_equal() + 
  theme_bw() +
  theme(legend.position = "none")+
  facet_grid(type~.)
  
```



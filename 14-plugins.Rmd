```{r,echo=FALSE,message=FALSE,warning=FALSE}
library(lidR)
knitr::opts_chunk$set(
  comment =  "#>", 
  collapse = TRUE,
  fig.align = "center")
```

# `lidR` plugin system {#plugins}

We have seen that `lidR` has many functions capable of processing a collection of files. Most of these functions support more than one algorithm to achieve a given task. 

* `grid_terrain()` supports `tin()`, `knnidw()`, `kriging()`
* `grid_canopy()` supports `p2r()`, `dsmtin()`, `pitfree()` etc.

What if a user wanted to create a new algorithm integration? For example, what about an algorithm to create a digital terrain model using cubic spline interpolation? Sounds interesting.

With `catalog_apply()` one can more or less replicate the original `grid_terrain()` function and apply the method over a catalog. After all, `grid_terrain()` actually uses `catalog_apply()` internally. However this implies a lot of code and is error prone especially for users who are not fully comfortable with the engine.

There is another way to create new algorithms that are fully compatible with `lidR` functions. This is not documented in the package because the underlying mechanism is not yet fully consistent and is still subject to improvements. 

Let's continue with the bicubic spline interpolation method for creating a digital terrain model. There is a package called [`MBA`](https://CRAN.R-project.org/package=MBA) that implements bicubic spline interpolation. We will create a function `mba()` that can be used like any other algorithm:

```r
dtm <- grid_terrain(las, algorithm = mba(n = 1, h = 8))
```

## Understanding lidR algorithms

In `lidR`, an algorithm such as `tin()`, `p2r()` or `lmf()` is a function factory. The output is functions with extra classes so regular users wont immediately recognize that they are functions.

```{r}
algo <- knnidw(k = 10)
algo
class(algo) # algo is a function
```

Removing the extra classes we can see its a function and we can see the source code.

```{r}
class(algo) <- "function"
algo
```

We can see how a function designed to be used in `grid_terrain()` is designed. The signature is 

```r
function(what, where, scales = c(0,0), offsets = c(0,0))
```

When creating a new algorithm for spatial interpolation, the function factory must return a function similar to what you see above. In the case of spatial interpolation `what` is a `data.frame` with X Y and Z coordinates of ground points. `where` is a `data.frame` with the X Y coordinates of the location where we want to interpolate Z. It also receives `scale` and `offset` but we can ignore them in this case. The function returns a vector of Z coordinates at these locations.

## Creation of the `mba` algorithm

Now let's create our `mba` algorithm. 

```{r}
# mba is our function factory
mba <- function(n = 1, m = 1, h = 8, extend = TRUE) {
  # f is created inside mba and receive the ground points (what)
  # and the location where to compute the interpolation (where) 
  f <- function(what, where, scales = c(0,0), offsets = c(0,0)) {
    # computation of the interpolation (see the documentation of MBA package)
    res <- MBA::mba.points(what, where, n, m , h, extend)
    return(res$xyz.est[,3])
  }
  
  # f is a function but we set compatible classes. Here it is an
  # algorithm for spatial interpolation (SPI) we use an internal global
  # variable to set the good classes
  class(f) <- lidR:::LIDRALGORITHMSPI
  return(f)
}
```

Now let see what happens if we instantiate the `mba` algorithm:

```{r}
algo <- mba(h = 6)
algo
```

We can now use it like any other `lidR` algorithm:

```{r, fig.height=7.5, fig.width=7.7}
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las <- readLAS(LASfile)
dtm <- grid_terrain(las, algorithm = mba())
plot(dtm, col = gray.colors(50, 0, 1))
```

It will even fail nicely if used poorly!

```{r, error = TRUE}
grid_canopy(las, 1, mba())
```

## What about other algorithms?

`lidR` has algorithms for canopy height models, individual tree segmentation, individual tree detection, sensor tracking, snag segmentation and so on. They all have different behaviors and this is why it's difficult to document. If you want to create a new algorithm the best first step is to communicate directly with `lidR` developers :).

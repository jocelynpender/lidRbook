<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>18 Spatial indexes | The lidR package</title>
  <meta name="description" content="A guide to the lidR package" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="18 Spatial indexes | The lidR package" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A guide to the lidR package" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="18 Spatial indexes | The lidR package" />
  
  <meta name="twitter:description" content="A guide to the lidR package" />
  

<meta name="author" content="Jean-Romain Roussel, Tristan R.H. Goodbody, Piotr Tompalski" />


<meta name="date" content="2020-12-17" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="outbox.html"/>
<link rel="next" href="plugins.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a></li>
<li class="chapter" data-level="2" data-path="io.html"><a href="io.html"><i class="fa fa-check"></i><b>2</b> Reading, Plotting, Querying &amp; Validating</a><ul>
<li class="chapter" data-level="2.1" data-path="io.html"><a href="io.html#read"><i class="fa fa-check"></i><b>2.1</b> Reading LiDAR data using <code>readLAS</code></a><ul>
<li class="chapter" data-level="2.1.1" data-path="io.html"><a href="io.html#select"><i class="fa fa-check"></i><b>2.1.1</b> Parameter <code>select</code></a></li>
<li class="chapter" data-level="2.1.2" data-path="io.html"><a href="io.html#filter"><i class="fa fa-check"></i><b>2.1.2</b> Parameter <code>filter</code></a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="io.html"><a href="io.html#asprs-compliance"><i class="fa fa-check"></i><b>2.2</b> Validating lidar data</a></li>
<li class="chapter" data-level="2.3" data-path="io.html"><a href="io.html#plot"><i class="fa fa-check"></i><b>2.3</b> Plotting</a><ul>
<li class="chapter" data-level="2.3.1" data-path="io.html"><a href="io.html#plot-3d"><i class="fa fa-check"></i><b>2.3.1</b> Basic 3D rendering</a></li>
<li class="chapter" data-level="2.3.2" data-path="io.html"><a href="io.html#plot-overlay"><i class="fa fa-check"></i><b>2.3.2</b> Overlays</a></li>
<li class="chapter" data-level="2.3.3" data-path="io.html"><a href="io.html#plot-advanced"><i class="fa fa-check"></i><b>2.3.3</b> Advanced 3D rendering</a></li>
<li class="chapter" data-level="2.3.4" data-path="io.html"><a href="io.html#plot-crossection"><i class="fa fa-check"></i><b>2.3.4</b> Cross sections 2D rendering</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="gnd.html"><a href="gnd.html"><i class="fa fa-check"></i><b>3</b> Ground classification</a><ul>
<li class="chapter" data-level="3.1" data-path="gnd.html"><a href="gnd.html#pmf"><i class="fa fa-check"></i><b>3.1</b> Progressive Morphological Filter</a></li>
<li class="chapter" data-level="3.2" data-path="gnd.html"><a href="gnd.html#csf"><i class="fa fa-check"></i><b>3.2</b> Cloth Simulation Function</a></li>
<li class="chapter" data-level="3.3" data-path="gnd.html"><a href="gnd.html#edge-artifact"><i class="fa fa-check"></i><b>3.3</b> Edge artifacts</a></li>
<li class="chapter" data-level="3.4" data-path="gnd.html"><a href="gnd.html#method-selection"><i class="fa fa-check"></i><b>3.4</b> How to choose a method and its parameters?</a></li>
<li class="chapter" data-level="3.5" data-path="gnd.html"><a href="gnd.html#other"><i class="fa fa-check"></i><b>3.5</b> Other methods</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="dtm.html"><a href="dtm.html"><i class="fa fa-check"></i><b>4</b> Digital terrain model</a><ul>
<li class="chapter" data-level="4.1" data-path="dtm.html"><a href="dtm.html#tin"><i class="fa fa-check"></i><b>4.1</b> Triangular irregular network</a></li>
<li class="chapter" data-level="4.2" data-path="dtm.html"><a href="dtm.html#idw"><i class="fa fa-check"></i><b>4.2</b> Invert distance weighting</a></li>
<li class="chapter" data-level="4.3" data-path="dtm.html"><a href="dtm.html#kriging"><i class="fa fa-check"></i><b>4.3</b> Kriging</a></li>
<li class="chapter" data-level="4.4" data-path="dtm.html"><a href="dtm.html#dtm-pros-cons"><i class="fa fa-check"></i><b>4.4</b> Pros and cons</a></li>
<li class="chapter" data-level="4.5" data-path="dtm.html"><a href="dtm.html#dtm-other"><i class="fa fa-check"></i><b>4.5</b> Other methods</a></li>
<li class="chapter" data-level="4.6" data-path="dtm.html"><a href="dtm.html#hillshade"><i class="fa fa-check"></i><b>4.6</b> Render shaded DTM</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="norm.html"><a href="norm.html"><i class="fa fa-check"></i><b>5</b> Height normalization</a><ul>
<li class="chapter" data-level="5.1" data-path="norm.html"><a href="norm.html#norm-dtm"><i class="fa fa-check"></i><b>5.1</b> DTM normalization</a></li>
<li class="chapter" data-level="5.2" data-path="norm.html"><a href="norm.html#norm-point-cloud"><i class="fa fa-check"></i><b>5.2</b> Point cloud normalization</a></li>
<li class="chapter" data-level="5.3" data-path="norm.html"><a href="norm.html#norm-pros-cons"><i class="fa fa-check"></i><b>5.3</b> Pros and cons</a></li>
<li class="chapter" data-level="5.4" data-path="norm.html"><a href="norm.html#norm-reverse"><i class="fa fa-check"></i><b>5.4</b> Reversing normalization</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="chm.html"><a href="chm.html"><i class="fa fa-check"></i><b>6</b> Digital Surface Model and Canopy Height model</a><ul>
<li class="chapter" data-level="6.1" data-path="chm.html"><a href="chm.html#p2r"><i class="fa fa-check"></i><b>6.1</b> Point-to-raster</a></li>
<li class="chapter" data-level="6.2" data-path="chm.html"><a href="chm.html#chm-tin"><i class="fa fa-check"></i><b>6.2</b> Triangulation</a></li>
<li class="chapter" data-level="6.3" data-path="chm.html"><a href="chm.html#pitfree"><i class="fa fa-check"></i><b>6.3</b> Pit-free algorithm</a></li>
<li class="chapter" data-level="6.4" data-path="chm.html"><a href="chm.html#chm-post-process"><i class="fa fa-check"></i><b>6.4</b> Post-processing a CHM</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="itd-its.html"><a href="itd-its.html"><i class="fa fa-check"></i><b>7</b> Indivitual tree dectection and segmentation</a><ul>
<li class="chapter" data-level="7.1" data-path="itd-its.html"><a href="itd-its.html#itd"><i class="fa fa-check"></i><b>7.1</b> Individual Tree Detection (ITD)</a><ul>
<li class="chapter" data-level="7.1.1" data-path="itd-its.html"><a href="itd-its.html#lmffw"><i class="fa fa-check"></i><b>7.1.1</b> Local Maximum Filter with fixed windows size</a></li>
<li class="chapter" data-level="7.1.2" data-path="itd-its.html"><a href="itd-its.html#lmfvw"><i class="fa fa-check"></i><b>7.1.2</b> Local Maximum Filter with variable windows size</a></li>
<li class="chapter" data-level="7.1.3" data-path="itd-its.html"><a href="itd-its.html#lmfchm"><i class="fa fa-check"></i><b>7.1.3</b> Local Maximum Filter on a CHM</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="itd-its.html"><a href="itd-its.html#its"><i class="fa fa-check"></i><b>7.2</b> Individual Tree Segmentation (ITS)</a><ul>
<li class="chapter" data-level="7.2.1" data-path="itd-its.html"><a href="itd-its.html#its-cloud"><i class="fa fa-check"></i><b>7.2.1</b> Segmentation of the point-cloud</a></li>
<li class="chapter" data-level="7.2.2" data-path="itd-its.html"><a href="itd-its.html#its-chm"><i class="fa fa-check"></i><b>7.2.2</b> Segmentation of the CHM</a></li>
<li class="chapter" data-level="7.2.3" data-path="itd-its.html"><a href="itd-its.html#its-comparaison"><i class="fa fa-check"></i><b>7.2.3</b> Comparaison of tree segmentations</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="metrics.html"><a href="metrics.html"><i class="fa fa-check"></i><b>8</b> Derived metrics</a><ul>
<li class="chapter" data-level="8.1" data-path="metrics.html"><a href="metrics.html#metrics-basics"><i class="fa fa-check"></i><b>8.1</b> The basics</a></li>
<li class="chapter" data-level="8.2" data-path="metrics.html"><a href="metrics.html#metrics-user-defined"><i class="fa fa-check"></i><b>8.2</b> User-defined metrics</a></li>
<li class="chapter" data-level="8.3" data-path="metrics.html"><a href="metrics.html#metrics-pre-defined"><i class="fa fa-check"></i><b>8.3</b> Pre-defined metrics</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="cba.html"><a href="cba.html"><i class="fa fa-check"></i><b>9</b> Derived metrics at the cloud level</a><ul>
<li class="chapter" data-level="9.1" data-path="cba.html"><a href="cba.html#cba-overview"><i class="fa fa-check"></i><b>9.1</b> Overview</a></li>
<li class="chapter" data-level="9.2" data-path="cba.html"><a href="cba.html#cba-applications"><i class="fa fa-check"></i><b>9.2</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="aba.html"><a href="aba.html"><i class="fa fa-check"></i><b>10</b> Derived metrics at the grid level</a><ul>
<li class="chapter" data-level="10.1" data-path="aba.html"><a href="aba.html#aba-overview"><i class="fa fa-check"></i><b>10.1</b> Overview</a></li>
<li class="chapter" data-level="10.2" data-path="aba.html"><a href="aba.html#aba-applications"><i class="fa fa-check"></i><b>10.2</b> Applications</a><ul>
<li class="chapter" data-level="10.2.1" data-path="aba.html"><a href="aba.html#aba-applications-modeling"><i class="fa fa-check"></i><b>10.2.1</b> Modeling</a></li>
<li class="chapter" data-level="10.2.2" data-path="aba.html"><a href="aba.html#aba-applications-density"><i class="fa fa-check"></i><b>10.2.2</b> Density</a></li>
<li class="chapter" data-level="10.2.3" data-path="aba.html"><a href="aba.html#aba-applications-intensity"><i class="fa fa-check"></i><b>10.2.3</b> Intensity</a></li>
<li class="chapter" data-level="10.2.4" data-path="aba.html"><a href="aba.html#aba-applications-other"><i class="fa fa-check"></i><b>10.2.4</b> Other</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="tba.html"><a href="tba.html"><i class="fa fa-check"></i><b>11</b> Derived metrics at the tree level</a><ul>
<li class="chapter" data-level="11.1" data-path="tba.html"><a href="tba.html#tba-overview"><i class="fa fa-check"></i><b>11.1</b> Overview</a></li>
<li class="chapter" data-level="11.2" data-path="tba.html"><a href="tba.html#tba-applications"><i class="fa fa-check"></i><b>11.2</b> Applications</a><ul>
<li class="chapter" data-level="11.2.1" data-path="tba.html"><a href="tba.html#tba-applications-tree-selection"><i class="fa fa-check"></i><b>11.2.1</b> Selection of trees</a></li>
<li class="chapter" data-level="11.2.2" data-path="tba.html"><a href="tba.html#tba-applications-tree-inventory"><i class="fa fa-check"></i><b>11.2.2</b> Tree based inventory</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="vba.html"><a href="vba.html"><i class="fa fa-check"></i><b>12</b> Derived metrics at the voxel level</a><ul>
<li class="chapter" data-level="12.1" data-path="vba.html"><a href="vba.html#vba-overview"><i class="fa fa-check"></i><b>12.1</b> Overview</a></li>
<li class="chapter" data-level="12.2" data-path="vba.html"><a href="vba.html#vba-applications"><i class="fa fa-check"></i><b>12.2</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="pba.html"><a href="pba.html"><i class="fa fa-check"></i><b>13</b> Derived metrics at point level</a><ul>
<li class="chapter" data-level="13.1" data-path="pba.html"><a href="pba.html#pba-overview"><i class="fa fa-check"></i><b>13.1</b> Overview</a></li>
<li class="chapter" data-level="13.2" data-path="pba.html"><a href="pba.html#pba-applications"><i class="fa fa-check"></i><b>13.2</b> Applications</a><ul>
<li class="chapter" data-level="13.2.1" data-path="pba.html"><a href="pba.html#pba-applications-roof"><i class="fa fa-check"></i><b>13.2.1</b> Roof segmentation</a></li>
<li class="chapter" data-level="13.2.2" data-path="pba.html"><a href="pba.html#pba-applications-wire"><i class="fa fa-check"></i><b>13.2.2</b> Lake and wire segmentation</a></li>
<li class="chapter" data-level="13.2.3" data-path="pba.html"><a href="pba.html#pba-applications-coloring"><i class="fa fa-check"></i><b>13.2.3</b> Multi-spectral coloring</a></li>
<li class="chapter" data-level="13.2.4" data-path="pba.html"><a href="pba.html#pba-applications-outliers"><i class="fa fa-check"></i><b>13.2.4</b> Outlier filtering</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="14" data-path="engine.html"><a href="engine.html"><i class="fa fa-check"></i><b>14</b> <code>LAScatalog</code> processing engine (1/2)</a><ul>
<li class="chapter" data-level="14.1" data-path="engine.html"><a href="engine.html#engine-rationale"><i class="fa fa-check"></i><b>14.1</b> Rationale for <code>LAScatalog</code> functionality</a></li>
<li class="chapter" data-level="14.2" data-path="engine.html"><a href="engine.html#engine-engine"><i class="fa fa-check"></i><b>14.2</b> The <code>LAScatalog</code> engine</a></li>
<li class="chapter" data-level="14.3" data-path="engine.html"><a href="engine.html#engine-lascatalog"><i class="fa fa-check"></i><b>14.3</b> Read a collection of files</a></li>
<li class="chapter" data-level="14.4" data-path="engine.html"><a href="engine.html#engine-asprs-compliance"><i class="fa fa-check"></i><b>14.4</b> Validation</a></li>
<li class="chapter" data-level="14.5" data-path="engine.html"><a href="engine.html#engine-clip"><i class="fa fa-check"></i><b>14.5</b> Extract Regions of interest</a><ul>
<li class="chapter" data-level="14.5.1" data-path="engine.html"><a href="engine.html#engine-clip-single"><i class="fa fa-check"></i><b>14.5.1</b> Extract a single ROI</a></li>
<li class="chapter" data-level="14.5.2" data-path="engine.html"><a href="engine.html#engine-clip-multiple"><i class="fa fa-check"></i><b>14.5.2</b> Multiple extractions</a></li>
</ul></li>
<li class="chapter" data-level="14.6" data-path="engine.html"><a href="engine.html#engine-options"><i class="fa fa-check"></i><b>14.6</b> Modification of default behavior</a><ul>
<li class="chapter" data-level="14.6.1" data-path="engine.html"><a href="engine.html#engine-options-ondisk"><i class="fa fa-check"></i><b>14.6.1</b> Multiple extractions on disk</a></li>
<li class="chapter" data-level="14.6.2" data-path="engine.html"><a href="engine.html#engine-options-index"><i class="fa fa-check"></i><b>14.6.2</b> Multiple extraction with point cloud indexation</a></li>
<li class="chapter" data-level="14.6.3" data-path="engine.html"><a href="engine.html#summary"><i class="fa fa-check"></i><b>14.6.3</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="14.7" data-path="engine.html"><a href="engine.html#engine-gnd-classification"><i class="fa fa-check"></i><b>14.7</b> Ground classification</a><ul>
<li class="chapter" data-level="14.7.1" data-path="engine.html"><a href="engine.html#engine-options-chunk"><i class="fa fa-check"></i><b>14.7.1</b> Chunk processing</a></li>
<li class="chapter" data-level="14.7.2" data-path="engine.html"><a href="engine.html#engine-options-chunk-buffer"><i class="fa fa-check"></i><b>14.7.2</b> Modifying buffers</a></li>
<li class="chapter" data-level="14.7.3" data-path="engine.html"><a href="engine.html#engine-options-chunk-size"><i class="fa fa-check"></i><b>14.7.3</b> Modify the chunk size</a></li>
<li class="chapter" data-level="14.7.4" data-path="engine.html"><a href="engine.html#engine-options-parallel"><i class="fa fa-check"></i><b>14.7.4</b> Parallel processing</a></li>
<li class="chapter" data-level="14.7.5" data-path="engine.html"><a href="engine.html#summary-1"><i class="fa fa-check"></i><b>14.7.5</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="14.8" data-path="engine.html"><a href="engine.html#engine-dtm"><i class="fa fa-check"></i><b>14.8</b> Digital Terrain Model</a><ul>
<li class="chapter" data-level="14.8.1" data-path="engine.html"><a href="engine.html#engine-dtm-inmemory"><i class="fa fa-check"></i><b>14.8.1</b> In memory DTM</a></li>
<li class="chapter" data-level="14.8.2" data-path="engine.html"><a href="engine.html#engine-dtm-ondisk"><i class="fa fa-check"></i><b>14.8.2</b> On disk DTM</a></li>
<li class="chapter" data-level="14.8.3" data-path="engine.html"><a href="engine.html#summary-2"><i class="fa fa-check"></i><b>14.8.3</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="14.9" data-path="engine.html"><a href="engine.html#engine-normalization"><i class="fa fa-check"></i><b>14.9</b> Height normalization</a></li>
<li class="chapter" data-level="14.10" data-path="engine.html"><a href="engine.html#engine-aba"><i class="fa fa-check"></i><b>14.10</b> Area Based Approach</a><ul>
<li class="chapter" data-level="14.10.1" data-path="engine.html"><a href="engine.html#summary-3"><i class="fa fa-check"></i><b>14.10.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="14.11" data-path="engine.html"><a href="engine.html#engine-itd"><i class="fa fa-check"></i><b>14.11</b> Individual Tree Detection</a><ul>
<li class="chapter" data-level="14.11.1" data-path="engine.html"><a href="engine.html#summary-4"><i class="fa fa-check"></i><b>14.11.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="14.12" data-path="engine.html"><a href="engine.html#engine-its"><i class="fa fa-check"></i><b>14.12</b> Individual Tree Segmentation</a></li>
<li class="chapter" data-level="14.13" data-path="engine.html"><a href="engine.html#engine-retile"><i class="fa fa-check"></i><b>14.13</b> Retile a catalog</a><ul>
<li class="chapter" data-level="14.13.1" data-path="engine.html"><a href="engine.html#retile-a-catalog-into-smaller-files"><i class="fa fa-check"></i><b>14.13.1</b> Retile a catalog into smaller files</a></li>
<li class="chapter" data-level="14.13.2" data-path="engine.html"><a href="engine.html#add-a-buffer-around-each-file"><i class="fa fa-check"></i><b>14.13.2</b> Add a buffer around each file</a></li>
<li class="chapter" data-level="14.13.3" data-path="engine.html"><a href="engine.html#create-a-new-collection-with-only-first-returns"><i class="fa fa-check"></i><b>14.13.3</b> Create a new collection with only first returns</a></li>
<li class="chapter" data-level="14.13.4" data-path="engine.html"><a href="engine.html#create-a-new-collection-of-small-and-buffered-ground-returns-in-parallel"><i class="fa fa-check"></i><b>14.13.4</b> Create a new collection of small and buffered ground returns in parallel</a></li>
</ul></li>
<li class="chapter" data-level="14.14" data-path="engine.html"><a href="engine.html#engine-independent-files"><i class="fa fa-check"></i><b>14.14</b> The case of ground inventories</a></li>
<li class="chapter" data-level="14.15" data-path="engine.html"><a href="engine.html#engine-summary-sheet"><i class="fa fa-check"></i><b>14.15</b> Summary of available options</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="engine2.html"><a href="engine2.html"><i class="fa fa-check"></i><b>15</b> LAScatalog processing engine (2/2)</a><ul>
<li class="chapter" data-level="15.1" data-path="engine2.html"><a href="engine2.html#engine-catalog-apply"><i class="fa fa-check"></i><b>15.1</b> <code>catalog_apply()</code></a></li>
<li class="chapter" data-level="15.2" data-path="engine2.html"><a href="engine2.html#engine-user-function-generic"><i class="fa fa-check"></i><b>15.2</b> Create user-defined function</a></li>
<li class="chapter" data-level="15.3" data-path="engine2.html"><a href="engine2.html#engine-user-function-extended"><i class="fa fa-check"></i><b>15.3</b> Create an intermediate function for <code>catalog_apply()</code></a></li>
<li class="chapter" data-level="15.4" data-path="engine2.html"><a href="engine2.html#engine-user-function-lascatalog"><i class="fa fa-check"></i><b>15.4</b> Make a user-friendly function for third party users</a></li>
<li class="chapter" data-level="15.5" data-path="engine2.html"><a href="engine2.html#engine-user-function-safe"><i class="fa fa-check"></i><b>15.5</b> Make a safe function for third party users</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="modeling-aba.html"><a href="modeling-aba.html"><i class="fa fa-check"></i><b>16</b> The Area-Based Approach (ABA) to forest modelling</a><ul>
<li class="chapter" data-level="16.1" data-path="modeling-aba.html"><a href="modeling-aba.html#modeling-read-data"><i class="fa fa-check"></i><b>16.1</b> Read in data</a></li>
<li class="chapter" data-level="16.2" data-path="modeling-aba.html"><a href="modeling-aba.html#modeling-build-model"><i class="fa fa-check"></i><b>16.2</b> ABA Processing</a><ul>
<li class="chapter" data-level="16.2.1" data-path="modeling-aba.html"><a href="modeling-aba.html#step-1---clip-als-ground-inventory"><i class="fa fa-check"></i><b>16.2.1</b> Step 1 - Clip ALS ground inventory</a></li>
<li class="chapter" data-level="16.2.2" data-path="modeling-aba.html"><a href="modeling-aba.html#step-2---calculate-plot-metrics"><i class="fa fa-check"></i><b>16.2.2</b> Step 2 - Calculate plot metrics</a></li>
<li class="chapter" data-level="16.2.3" data-path="modeling-aba.html"><a href="modeling-aba.html#step-3---modeling"><i class="fa fa-check"></i><b>16.2.3</b> Step 3 - Modeling</a></li>
<li class="chapter" data-level="16.2.4" data-path="modeling-aba.html"><a href="modeling-aba.html#step-4---wall-to-wall-modelling"><i class="fa fa-check"></i><b>16.2.4</b> Step 4 - Wall to wall modelling</a></li>
<li class="chapter" data-level="16.2.5" data-path="modeling-aba.html"><a href="modeling-aba.html#step-5---calculate-wall-to-wall-predictions"><i class="fa fa-check"></i><b>16.2.5</b> Step 5 - Calculate wall-to-wall predictions</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="outbox.html"><a href="outbox.html"><i class="fa fa-check"></i><b>17</b> Thinking outside the box</a><ul>
<li class="chapter" data-level="17.1" data-path="outbox.html"><a href="outbox.html#outbox-custom-metrics"><i class="fa fa-check"></i><b>17.1</b> New complex metrics in ABA</a><ul>
<li class="chapter" data-level="17.1.1" data-path="outbox.html"><a href="outbox.html#outbox-distance-returns"><i class="fa fa-check"></i><b>17.1.1</b> Distance between returns</a></li>
<li class="chapter" data-level="17.1.2" data-path="outbox.html"><a href="outbox.html#outbox-rumple-index"><i class="fa fa-check"></i><b>17.1.2</b> Rumple index</a></li>
</ul></li>
<li class="chapter" data-level="17.2" data-path="outbox.html"><a href="outbox.html#outbox-multispectral-coloring"><i class="fa fa-check"></i><b>17.2</b> Multi-spectral coloring</a></li>
</ul></li>
<li class="chapter" data-level="18" data-path="spatial-index.html"><a href="spatial-index.html"><i class="fa fa-check"></i><b>18</b> Spatial indexes</a><ul>
<li class="chapter" data-level="18.1" data-path="spatial-index.html"><a href="spatial-index.html#introduction-to-spatial-indexes"><i class="fa fa-check"></i><b>18.1</b> Introduction to spatial indexes</a></li>
<li class="chapter" data-level="18.2" data-path="spatial-index.html"><a href="spatial-index.html#spatial-indexes-for-las-objects"><i class="fa fa-check"></i><b>18.2</b> Spatial indexes for LAS objects</a><ul>
<li class="chapter" data-level="18.2.1" data-path="spatial-index.html"><a href="spatial-index.html#overview"><i class="fa fa-check"></i><b>18.2.1</b> Overview</a></li>
<li class="chapter" data-level="18.2.2" data-path="spatial-index.html"><a href="spatial-index.html#spatial-indexes-and-selection-strategies"><i class="fa fa-check"></i><b>18.2.2</b> Spatial indexes and selection strategies</a></li>
<li class="chapter" data-level="18.2.3" data-path="spatial-index.html"><a href="spatial-index.html#c-api"><i class="fa fa-check"></i><b>18.2.3</b> C++ API</a></li>
<li class="chapter" data-level="18.2.4" data-path="spatial-index.html"><a href="spatial-index.html#benchmark"><i class="fa fa-check"></i><b>18.2.4</b> Benchmark</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="spatial-index.html"><a href="spatial-index.html#spatial-index-for-las-files"><i class="fa fa-check"></i><b>18.3</b> Spatial index for LAS files</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="plugins.html"><a href="plugins.html"><i class="fa fa-check"></i><b>19</b> <code>lidR</code> plugin system</a><ul>
<li class="chapter" data-level="19.1" data-path="plugins.html"><a href="plugins.html#plugin-system"><i class="fa fa-check"></i><b>19.1</b> Understanding lidR algorithms</a></li>
<li class="chapter" data-level="19.2" data-path="plugins.html"><a href="plugins.html#plugin-creation"><i class="fa fa-check"></i><b>19.2</b> Creation of the <code>mba</code> algorithm</a></li>
<li class="chapter" data-level="19.3" data-path="plugins.html"><a href="plugins.html#plugin-extensions"><i class="fa fa-check"></i><b>19.3</b> What about other algorithms?</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">The <code>lidR</code> package</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-index" class="section level1">
<h1><span class="header-section-number">18</span> Spatial indexes</h1>
<p>Spatial index is one key features for performing spatial queries in a large point-cloud. Without indexing, any search for points of interest would require a “sequential scan” of every points. Indexing speeds up searching by organizing the data into a search structure which can be quickly traversed to find particular records. Some algorithms could simply not work in a reasonable time-frame without spatial indexing.</p>
<div id="introduction-to-spatial-indexes" class="section level2">
<h2><span class="header-section-number">18.1</span> Introduction to spatial indexes</h2>
<p>This section presents an overview, with simple words, of how spatial indexes works. If the reader is already knowledgeable about spatial indexing, they can skip this section which only skim over the concept of spatial index.</p>
<p>Imagine that with have 1,000,000 points (which is not a lot). We want to query all the points that belong in a disc centred on p(300, 350) with a radius of 25 meters. This is a typical query made thousands of times per second by many algorithms such as the local maximum filter used to locate individual trees. Without spatial index, the method consists in computing the distance to <code>p</code> for every single point. This is called ‘sequential scan’ and it requires to computes 1,000,000 times the distance and perform 1,000,000 comparisons for a point cloud with 1,000,000 points. In R we can write:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="spatial-index.html#cb1-1"></a>p =<span class="st"> </span><span class="kw">c</span>(<span class="dv">300</span>, <span class="dv">350</span>)</span>
<span id="cb1-2"><a href="spatial-index.html#cb1-2"></a>R =<span class="st"> </span><span class="dv">25</span></span>
<span id="cb1-3"><a href="spatial-index.html#cb1-3"></a>X =<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e4</span>, <span class="dv">0</span>, <span class="dv">1000</span>)</span>
<span id="cb1-4"><a href="spatial-index.html#cb1-4"></a>Y =<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e4</span>, <span class="dv">0</span>, <span class="dv">1000</span>)</span>
<span id="cb1-5"><a href="spatial-index.html#cb1-5"></a>query =<span class="st"> </span><span class="kw">sqrt</span>((X <span class="op">-</span><span class="st"> </span>p[<span class="dv">1</span>])<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(Y <span class="op">-</span><span class="st"> </span>p[<span class="dv">2</span>])<span class="op">^</span><span class="dv">2</span>) <span class="op">&lt;</span><span class="st"> </span>R</span>
<span id="cb1-6"><a href="spatial-index.html#cb1-6"></a>Xq =<span class="st"> </span>X[query]</span>
<span id="cb1-7"><a href="spatial-index.html#cb1-7"></a>Yq =<span class="st"> </span>Y[query]</span></code></pre></div>
<p><img src="lidR-book_files/figure-html/plot-sequential-scan-1.png" width="422.4" style="display: block; margin: auto;" /></p>
<p>This is typically what the function <code>filter_poi()</code> does because <code>filter_poi()</code> is not a specialized function and enables to query any kind of points of interest (POI) including non spatial queries such as <code>Intensity &gt; x</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="spatial-index.html#cb2-1"></a><span class="kw">filter_poi</span>(las, <span class="kw">sqrt</span>((X <span class="op">-</span><span class="st"> </span>p[<span class="dv">1</span>])<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(Y <span class="op">-</span><span class="st"> </span>p[<span class="dv">2</span>])<span class="op">^</span><span class="dv">2</span>) <span class="op">&lt;</span><span class="st"> </span>R)</span></code></pre></div>
<p>Now imagine we want to perform 1,000,000 queries like that for 1,000,000 different points <code>p</code>. It means that we need to perform 1,000,000 x 1,000,000 = 1 billion operations. We say that it has a quadratic complexity. This does not scale-up and quickly becomes not computable (or at least dramatically slow).</p>
<p>With a spatial index the points are organized in such a way that the computer does not need to perform all the comparisons. In a quadtree, for example, the points are subdivided in 4 quadrants that are themselves subdivided in four quadrants and so on hierachically (see figure below). In that cases we can exclude 75% of the points (750,000 points) in 4 operations at the top level (in red). The bounding box of our query being [275,325]x[325,375] we know that the POIs do not belong in top-left quadrant ([0,500] x [500,1000]) nor in top-right quadrant ([500,1000] x [500,1000]) nor in bottom-right quadrant. At the second level (in blue) in 4 more operations we can exclude another 75% of the remaining points to search only in one quadrant. At this stage we can perform a sequential scan on only 1/16<sup>th</sup> of the points (i.e. 62,500 points) meaning that we discarded 937,500 points in 8 operations. Consequently our query is (roughly) 16 times faster. With more subdivision levels it is even faster. In <code>lidR</code> a typical quadtree has 8 levels i.e. the space is subdivided in (2<sup>8</sup>)<sup>2</sup> = 65536 quadrants.</p>
<p><img src="lidR-book_files/figure-html/plot-quadtree-scan-1.png" width="422.4" style="display: block; margin: auto;" />
Spatial indexing provides a way to dramatically speed-up many common operations that require to perform spatial queries either in disc, rectangle, polygons, 2D, 3D and so on. It exists different types of spatial indexes for different purposes but in all case the uses of a spatial index is not free and comes at the cost of a greater memory usage.</p>
</div>
<div id="spatial-indexes-for-las-objects" class="section level2">
<h2><span class="header-section-number">18.2</span> Spatial indexes for LAS objects</h2>
<div id="overview" class="section level3">
<h3><span class="header-section-number">18.2.1</span> Overview</h3>
<p><code>lidR</code> makes use of spatial indexes in many functions and can choose different types of spatial indexes on-the-fly. So far, the book only presented the function <code>readLAS()</code> (see chapter <a href="io.html#io">2</a>) but the package has some variations of <code>readLAS()</code> named <code>readALSLAS()</code>, <code>readTLSLAS()</code>, <code>readUAVLAS()</code> and so on that enables to register a point-cloud type allowing <code>lidR</code> to adequately choose the most appropriated spatial index method to perform a given computation as fast as possible.</p>
<p>As an example we can use the TLS point-cloud <code>pine_plot.laz</code> from the <code>TreeLS</code> package. First we read it with <code>readLAS()</code>. In that case the point-cloud is considered as ALS because <code>lidR</code> was originally designed for ALS and by legacy <code>readLAS()</code> from version &lt;= 3.1 behaves optimally for ALS. In the second case we use <code>readTLSLAS()</code> to inform <code>lidR</code> that this point cloud was sampled with a terrestrial device. In the following test, the computation time dropped from ~2.5 sec to ~1.3 sec by registering the proper point type. Improvements may range from 2 to 10 times faster depending on the point cloud and the method used.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="spatial-index.html#cb3-1"></a>file &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;pine_plot.laz&quot;</span>, <span class="dt">package=</span><span class="st">&quot;TreeLS&quot;</span>)</span>
<span id="cb3-2"><a href="spatial-index.html#cb3-2"></a>las &lt;-<span class="st"> </span><span class="kw">readLAS</span>(file, <span class="dt">select=</span><span class="st">&#39;xyz&#39;</span>)</span>
<span id="cb3-3"><a href="spatial-index.html#cb3-3"></a>tls &lt;-<span class="st"> </span><span class="kw">readTLSLAS</span>(file, <span class="dt">select=</span><span class="st">&#39;xyz&#39;</span>)</span>
<span id="cb3-4"><a href="spatial-index.html#cb3-4"></a></span>
<span id="cb3-5"><a href="spatial-index.html#cb3-5"></a><span class="kw">system.time</span>(<span class="kw">segment_shapes</span>(las, <span class="kw">shp_plane</span>(<span class="dt">k =</span> <span class="dv">15</span>), <span class="st">&quot;Coplanar&quot;</span>))</span>
<span id="cb3-6"><a href="spatial-index.html#cb3-6"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb3-7"><a href="spatial-index.html#cb3-7"></a><span class="co">#&gt;   2.796   0.008   1.522</span></span>
<span id="cb3-8"><a href="spatial-index.html#cb3-8"></a><span class="kw">system.time</span>(<span class="kw">segment_shapes</span>(tls, <span class="kw">shp_plane</span>(<span class="dt">k =</span> <span class="dv">15</span>), <span class="st">&quot;Coplanar&quot;</span>))</span>
<span id="cb3-9"><a href="spatial-index.html#cb3-9"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb3-10"><a href="spatial-index.html#cb3-10"></a><span class="co">#&gt;   1.202   0.001   0.618</span></span></code></pre></div>
<p>This works for each method that implies many sequential spatial queries. In the following example we can observe a ~8 fold speed-up.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="spatial-index.html#cb4-1"></a><span class="kw">system.time</span>(<span class="kw">point_metrics</span>(las, <span class="dt">r =</span> <span class="dv">1</span>, <span class="op">~</span><span class="kw">length</span>(Z)))</span>
<span id="cb4-2"><a href="spatial-index.html#cb4-2"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb4-3"><a href="spatial-index.html#cb4-3"></a><span class="co">#&gt;   8.749   0.016   8.766</span></span>
<span id="cb4-4"><a href="spatial-index.html#cb4-4"></a><span class="kw">system.time</span>(<span class="kw">point_metrics</span>(tls, <span class="dt">r =</span> <span class="dv">1</span>, <span class="op">~</span><span class="kw">length</span>(Z)))</span>
<span id="cb4-5"><a href="spatial-index.html#cb4-5"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb4-6"><a href="spatial-index.html#cb4-6"></a><span class="co">#&gt;   1.235   0.005   1.240</span></span></code></pre></div>
<p>Let now try with an ALS point-cloud. We can observe that it is better to read and ALS point-cloud as ALS rather than as TLS (2 fold difference). This is because registering the correct point-cloud type enables to optimally select an appropriated spatial index internally.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="spatial-index.html#cb5-1"></a>als =<span class="st"> </span><span class="kw">readALSLAS</span>(<span class="st">&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;</span>)</span>
<span id="cb5-2"><a href="spatial-index.html#cb5-2"></a>tls =<span class="st"> </span><span class="kw">readTLSLAS</span>(<span class="st">&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;</span>)</span>
<span id="cb5-3"><a href="spatial-index.html#cb5-3"></a></span>
<span id="cb5-4"><a href="spatial-index.html#cb5-4"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(als, <span class="kw">sor</span>()))</span>
<span id="cb5-5"><a href="spatial-index.html#cb5-5"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb5-6"><a href="spatial-index.html#cb5-6"></a><span class="co">#&gt;   6.244   0.087   3.616</span></span>
<span id="cb5-7"><a href="spatial-index.html#cb5-7"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(tls, <span class="kw">sor</span>()))</span>
<span id="cb5-8"><a href="spatial-index.html#cb5-8"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb5-9"><a href="spatial-index.html#cb5-9"></a><span class="co">#&gt;  13.008   0.116   7.348</span></span></code></pre></div>
<p>As a conclusion it is always a good idea to use the new functions <code>readALSLAS()</code>, <code>readTLSLAS()</code>, <code>readDAPLAS()</code>, and so on introduced in <code>lidR v3.1.0</code>.</p>
<p>However reading the point-cloud with the correct <code>read*LAS()</code> function does not always guarantee to get the optimal performance. First, all the functions do not use spatial indexing or do not use the spatial index framework of <code>lidR</code>. This is the case of the <code>kriging()</code> function, for example, that is based on the <code>gstat</code> package. Second the choice of the spatial index relies on some assumptions that may not be met in some specific point-clouds. The internal dispatch is designed to work with ‘typical’ point-cloud under some assumptions. An ALS point-cloud is typically spatially large (1 km² or more) with little Z dispersion (0 to 40 meters) relatively to the XY dispersion (0 to 1000 meters). On the contrary an TLS point cloud is typically spatially narrow (3000 m²) with proportionally a lot a variations on Z relatively to XY. <code>read*LAS()</code> should be sufficient for most use cases but for some specific cases users can manually choose which spatial index suit best and this is the topic of the next section.</p>
</div>
<div id="spatial-indexes-and-selection-strategies" class="section level3">
<h3><span class="header-section-number">18.2.2</span> Spatial indexes and selection strategies</h3>
<p><code>lidR</code> currently has 4 spatial indexes: a grid partition, a voxel partition, a quadtree and an octree. Each having pros and cons. grid partition and quadtree are 2D indexes while voxel partition and octree are 3D indexes. They are all able to perform any kind of spatial query similarly. This is why it does not matter if the point-cloud is read with <code>readALSLAS()</code> or <code>readTLSLAS()</code>. The result will be the same. However their efficiency dependent on the point-cloud type and the query type. This is why using the proper <code>read</code> function can matter. The following rules allow to select the best index.</p>
<p>For ALS we use a 2D index even for 3D queries. Indeed an ALS point-cloud is ‘mostly 2D’ because more than <strong>99% of the dispersion is on XY</strong>. When querying the knn of a given point (3D query) from a 2D index the vast majority of the points are discarded on a 2D base. The remaining sequential scan occurs only on a very tiny fraction of the dataset. This is also true for a 3D index but querying a 3D spatial index is slower and thus in <code>lidR</code> our 2D indexes perform best for ALS. A grid partition is used by default because it is faster than a quadtree in most cases because in ALS points are <strong>uniformly distributed</strong> on XY.</p>
<p>The following example demonstrates how to manually register a spatial index and compare the computation times for a quadtree and an octree.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="spatial-index.html#cb6-1"></a>las =<span class="st"> </span><span class="kw">readLAS</span>(<span class="st">&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;</span>, <span class="dt">select =</span> <span class="st">&quot;xyz&quot;</span>)</span>
<span id="cb6-2"><a href="spatial-index.html#cb6-2"></a></span>
<span id="cb6-3"><a href="spatial-index.html#cb6-3"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;quadtree&quot;</span></span>
<span id="cb6-4"><a href="spatial-index.html#cb6-4"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(las, <span class="kw">sor</span>()))</span>
<span id="cb6-5"><a href="spatial-index.html#cb6-5"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb6-6"><a href="spatial-index.html#cb6-6"></a><span class="co">#&gt;   5.603   0.035   3.358</span></span>
<span id="cb6-7"><a href="spatial-index.html#cb6-7"></a></span>
<span id="cb6-8"><a href="spatial-index.html#cb6-8"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;octree&quot;</span></span>
<span id="cb6-9"><a href="spatial-index.html#cb6-9"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(las, <span class="kw">sor</span>()))</span>
<span id="cb6-10"><a href="spatial-index.html#cb6-10"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb6-11"><a href="spatial-index.html#cb6-11"></a><span class="co">#&gt;  12.636   0.222   7.988</span></span></code></pre></div>
<p>For TLS we use a 3D index because in this case the point are <strong>almost evenly distributed in XYZ</strong> and thus a 2D query does not allow for discarding a large fraction of the points and the sequential scan part remains important. An octree is used because points are expected to be <strong>not uniformly</strong> distributed on XYZ.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="spatial-index.html#cb7-1"></a>file &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;pine_plot.laz&quot;</span>, <span class="dt">package=</span><span class="st">&quot;TreeLS&quot;</span>)</span>
<span id="cb7-2"><a href="spatial-index.html#cb7-2"></a>las &lt;-<span class="st"> </span><span class="kw">readLAS</span>(file, <span class="dt">select=</span><span class="st">&#39;xyz&#39;</span>)</span>
<span id="cb7-3"><a href="spatial-index.html#cb7-3"></a></span>
<span id="cb7-4"><a href="spatial-index.html#cb7-4"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;quadtree&quot;</span></span>
<span id="cb7-5"><a href="spatial-index.html#cb7-5"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(las, <span class="kw">sor</span>()))</span>
<span id="cb7-6"><a href="spatial-index.html#cb7-6"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb7-7"><a href="spatial-index.html#cb7-7"></a><span class="co">#&gt;   1.602   0.036   1.081</span></span>
<span id="cb7-8"><a href="spatial-index.html#cb7-8"></a></span>
<span id="cb7-9"><a href="spatial-index.html#cb7-9"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;octree&quot;</span></span>
<span id="cb7-10"><a href="spatial-index.html#cb7-10"></a><span class="kw">system.time</span>(<span class="kw">classify_noise</span>(las, <span class="kw">sor</span>()))</span>
<span id="cb7-11"><a href="spatial-index.html#cb7-11"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb7-12"><a href="spatial-index.html#cb7-12"></a><span class="co">#&gt;   0.519   0.012   0.279</span></span></code></pre></div>
<p>For DAP and UAV we apply the same rules. When encountering a dataset that do not follow these rules it may be clever to manually select a spatial index. This is the case of the dataset seen in chapter <a href="pba.html#pba-applications-roof">13.2.1</a> which is an ALS dataset but in practice it is a small subset in which we can no longer say that more than 99% of the point dispersion is on XY only. In that sense it is more a TLS-ish point-cloud. But in the meantime the points are uniformly spread on XY because it is actually an ALS dataset. Thus making 3D queries in a 3D index is maybe more clever. Let’s try out:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="spatial-index.html#cb8-1"></a>las &lt;-<span class="st"> </span><span class="kw">readLAS</span>(<span class="st">&quot;data/chap11/building_WilliamsAZ_Urban_normalized.laz&quot;</span>)</span>
<span id="cb8-2"><a href="spatial-index.html#cb8-2"></a></span>
<span id="cb8-3"><a href="spatial-index.html#cb8-3"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;gridpartition&quot;</span></span>
<span id="cb8-4"><a href="spatial-index.html#cb8-4"></a><span class="kw">system.time</span>(<span class="kw">segment_shapes</span>(las, <span class="kw">shp_plane</span>(<span class="dt">k =</span> <span class="dv">20</span>), <span class="st">&quot;planar&quot;</span>, <span class="dt">filter =</span> <span class="op">~</span>Classification <span class="op">!=</span><span class="st"> </span>LASGROUND))</span>
<span id="cb8-5"><a href="spatial-index.html#cb8-5"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb8-6"><a href="spatial-index.html#cb8-6"></a><span class="co">#&gt;   3.901   0.016   2.300</span></span>
<span id="cb8-7"><a href="spatial-index.html#cb8-7"></a></span>
<span id="cb8-8"><a href="spatial-index.html#cb8-8"></a><span class="kw">index</span>(las) &lt;-<span class="st"> &quot;voxelpartition&quot;</span></span>
<span id="cb8-9"><a href="spatial-index.html#cb8-9"></a><span class="kw">system.time</span>(<span class="kw">segment_shapes</span>(las, <span class="kw">shp_plane</span>(<span class="dt">k =</span> <span class="dv">20</span>), <span class="st">&quot;planar&quot;</span>, <span class="dt">filter =</span> <span class="op">~</span>Classification <span class="op">!=</span><span class="st"> </span>LASGROUND))</span>
<span id="cb8-10"><a href="spatial-index.html#cb8-10"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb8-11"><a href="spatial-index.html#cb8-11"></a><span class="co">#&gt;   3.720   0.056   2.077</span></span></code></pre></div>
<p>Here both are almost equal and “octree” is slower. But one may find limit cases where it worth it to perform manual selection and thus <code>lidR</code> allows for overwriting the default rules. More details in <code>help("lidR-spatial-index")</code>.</p>
</div>
<div id="c-api" class="section level3">
<h3><span class="header-section-number">18.2.3</span> C++ API</h3>
<p>For more advanced users and developers the lidR’s spatial index framework is provided as header-only C++ classes meaning that users can link to <code>lidR</code> to develop R/C++ applications using <code>lidR</code> spatial indexes. If the reader is not comfortable with the terms C++, Rcpp, header-only, external pointer and other C++ related concepts, all right, you can skip this section which is more dedicated to advanced users and package developers who want to develop complex and efficient tools but it does not bring much for regular users.</p>
<p>For the purpose of this example we will create a function <code>clip_disc()</code> similar to <code>clip_circle()</code> available in <code>lidR</code>. <code>clip_circle()</code> performs sequential scan and is thus not suitable to perform many queries in a loop for example. The function <code>clip_disc()</code> on the contrary will take advantage of spatial indexing.</p>
<p>There is only one C++ class to know named <code>SpatialIndex</code>. It has one constructor that accepts an <code>S4</code> class and has two public members <code>knn</code> and <code>lookup</code>.</p>
<p>First we can write a C++ function that returns a pointer on a <code>SpatialIndex</code>. Here we are using an external pointer because it is simple to write and implies fewer lines of code but we can also imagine taking advantage of Rcpp modules.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="spatial-index.html#cb9-1"></a><span class="co">// [[Rcpp::depends(lidR)]]</span></span>
<span id="cb9-2"><a href="spatial-index.html#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;SpatialIndex.h&gt;</span></span>
<span id="cb9-3"><a href="spatial-index.html#cb9-3"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</span>
<span id="cb9-4"><a href="spatial-index.html#cb9-4"></a><span class="kw">using</span> <span class="kw">namespace</span> lidR;</span>
<span id="cb9-5"><a href="spatial-index.html#cb9-5"></a></span>
<span id="cb9-6"><a href="spatial-index.html#cb9-6"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb9-7"><a href="spatial-index.html#cb9-7"></a>XPtr&lt;SpatialIndex&gt; spatial_index(S4 las) {</span>
<span id="cb9-8"><a href="spatial-index.html#cb9-8"></a>  SpatialIndex* idx = <span class="kw">new</span> SpatialIndex(las);</span>
<span id="cb9-9"><a href="spatial-index.html#cb9-9"></a>  XPtr&lt;SpatialIndex&gt; p(idx, <span class="kw">true</span>);</span>
<span id="cb9-10"><a href="spatial-index.html#cb9-10"></a>  <span class="cf">return</span> p;</span></code></pre></div>
<p>Now we can instantiate a <code>SpatialIndex</code> at R level</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="spatial-index.html#cb10-1"></a>las =<span class="st"> </span><span class="kw">readLAS</span>(<span class="st">&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;</span>)</span>
<span id="cb10-2"><a href="spatial-index.html#cb10-2"></a>index =<span class="st"> </span><span class="kw">spatial_index</span>(las)</span>
<span id="cb10-3"><a href="spatial-index.html#cb10-3"></a>index</span>
<span id="cb10-4"><a href="spatial-index.html#cb10-4"></a><span class="co">#&gt; &lt;pointer: 0x5612e437e440&gt;</span></span></code></pre></div>
<p>What has been created here is either a grid partition, a voxel partition, a quadtree or an octree depending on which <code>readLAS()</code> function was used to read the files or depending on the spatial index that was manually registered.</p>
<p>Then we can write the C++ side of the query.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="spatial-index.html#cb11-1"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb11-2"><a href="spatial-index.html#cb11-2"></a>IntegerVector filter_disc_with_index(SEXP xptr, <span class="dt">double</span> xc, <span class="dt">double</span> yc, <span class="dt">double</span> r) {</span>
<span id="cb11-3"><a href="spatial-index.html#cb11-3"></a>  XPtr&lt;SpatialIndex&gt; tree(xptr);</span>
<span id="cb11-4"><a href="spatial-index.html#cb11-4"></a>  Circle circ(xc, yc, r);</span>
<span id="cb11-5"><a href="spatial-index.html#cb11-5"></a>  <span class="bu">std::</span>vector&lt;PointXYZ&gt; pts;</span>
<span id="cb11-6"><a href="spatial-index.html#cb11-6"></a>  tree-&gt;lookup(circ, pts);</span>
<span id="cb11-7"><a href="spatial-index.html#cb11-7"></a></span>
<span id="cb11-8"><a href="spatial-index.html#cb11-8"></a>  IntegerVector ids(pts.size());</span>
<span id="cb11-9"><a href="spatial-index.html#cb11-9"></a>  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; pts.size(); i++) { ids[i] = pts[i].id; }</span>
<span id="cb11-10"><a href="spatial-index.html#cb11-10"></a>  <span class="cf">return</span> ids + <span class="dv">1</span>; <span class="co">// C++ is 0-indexed</span></span>
<span id="cb11-11"><a href="spatial-index.html#cb11-11"></a>}</span></code></pre></div>
<p>And the R side of the query</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="spatial-index.html#cb12-1"></a>clip_disc =<span class="st"> </span><span class="cf">function</span>(las, index, xcenter, ycenter, radius) {</span>
<span id="cb12-2"><a href="spatial-index.html#cb12-2"></a>  ii &lt;-<span class="st"> </span><span class="kw">filter_disc_with_index</span>(index, xcenter, ycenter, radius)</span>
<span id="cb12-3"><a href="spatial-index.html#cb12-3"></a>  <span class="kw">return</span>(las[ii])</span>
<span id="cb12-4"><a href="spatial-index.html#cb12-4"></a>}</span></code></pre></div>
<p>Now we can make a query a verify that both functions return the same points.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="spatial-index.html#cb13-1"></a>sub1 =<span class="st"> </span><span class="kw">clip_disc</span>(las, index, <span class="dv">338200</span>, <span class="dv">5238585</span>, <span class="dv">10</span>)</span>
<span id="cb13-2"><a href="spatial-index.html#cb13-2"></a>sub2 =<span class="st"> </span><span class="kw">clip_circle</span>(las, <span class="dv">338200</span>, <span class="dv">5238585</span>, <span class="dv">10</span>)</span>
<span id="cb13-3"><a href="spatial-index.html#cb13-3"></a>sub1</span>
<span id="cb13-4"><a href="spatial-index.html#cb13-4"></a><span class="co">#&gt; class        : LAS (v1.0 format 1)</span></span>
<span id="cb13-5"><a href="spatial-index.html#cb13-5"></a><span class="co">#&gt; memory       : 108.8 Kb </span></span>
<span id="cb13-6"><a href="spatial-index.html#cb13-6"></a><span class="co">#&gt; extent       : 338190, 338209.9, 5238575, 5238595 (xmin, xmax, ymin, ymax)</span></span>
<span id="cb13-7"><a href="spatial-index.html#cb13-7"></a><span class="co">#&gt; coord. ref.  : WGS 84 / UTM zone 19N </span></span>
<span id="cb13-8"><a href="spatial-index.html#cb13-8"></a><span class="co">#&gt; area         : 305.4827 m²</span></span>
<span id="cb13-9"><a href="spatial-index.html#cb13-9"></a><span class="co">#&gt; points       : 1.1 thousand points</span></span>
<span id="cb13-10"><a href="spatial-index.html#cb13-10"></a><span class="co">#&gt; density      : 3.75 points/m²</span></span>
<span id="cb13-11"><a href="spatial-index.html#cb13-11"></a>sub2</span>
<span id="cb13-12"><a href="spatial-index.html#cb13-12"></a><span class="co">#&gt; class        : LAS (v1.0 format 1)</span></span>
<span id="cb13-13"><a href="spatial-index.html#cb13-13"></a><span class="co">#&gt; memory       : 108.8 Kb </span></span>
<span id="cb13-14"><a href="spatial-index.html#cb13-14"></a><span class="co">#&gt; extent       : 338190, 338209.9, 5238575, 5238595 (xmin, xmax, ymin, ymax)</span></span>
<span id="cb13-15"><a href="spatial-index.html#cb13-15"></a><span class="co">#&gt; coord. ref.  : WGS 84 / UTM zone 19N </span></span>
<span id="cb13-16"><a href="spatial-index.html#cb13-16"></a><span class="co">#&gt; area         : 305.4827 m²</span></span>
<span id="cb13-17"><a href="spatial-index.html#cb13-17"></a><span class="co">#&gt; points       : 1.1 thousand points</span></span>
<span id="cb13-18"><a href="spatial-index.html#cb13-18"></a><span class="co">#&gt; density      : 3.75 points/m²</span></span></code></pre></div>
<p>While there is no gain with a single query because of the overhead of creating an index, it is indispensable to perform many successive queries. In the following we perform 50 queries in a loop.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="spatial-index.html#cb14-1"></a>n =<span class="st"> </span><span class="dv">50</span></span>
<span id="cb14-2"><a href="spatial-index.html#cb14-2"></a>x =<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">338000</span>, <span class="dv">338500</span>)</span>
<span id="cb14-3"><a href="spatial-index.html#cb14-3"></a>y =<span class="st"> </span><span class="kw">runif</span>(n, <span class="dv">5238500</span>, <span class="dv">5239000</span>)</span>
<span id="cb14-4"><a href="spatial-index.html#cb14-4"></a></span>
<span id="cb14-5"><a href="spatial-index.html#cb14-5"></a><span class="kw">system.time</span>(<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) <span class="dt">u =</span> <span class="kw">clip_circle</span>(las, x[i], y[i], <span class="dv">10</span>))</span>
<span id="cb14-6"><a href="spatial-index.html#cb14-6"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb14-7"><a href="spatial-index.html#cb14-7"></a><span class="co">#&gt;   1.821   0.104   1.846</span></span>
<span id="cb14-8"><a href="spatial-index.html#cb14-8"></a><span class="kw">system.time</span>(<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) <span class="dt">u =</span> <span class="kw">clip_disc</span>(las, index, x[i], y[i], <span class="dv">10</span>))</span>
<span id="cb14-9"><a href="spatial-index.html#cb14-9"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb14-10"><a href="spatial-index.html#cb14-10"></a><span class="co">#&gt;    0.16    0.00    0.09</span></span></code></pre></div>
<p>For more functionalities one can look at the source code of <a href="https://github.com/Jean-Romain/lidR/blob/devel/inst/include/SpatialIndex.h">SpatialIndex</a> where we can see there are actually 2 constructors and 5 members including 2D and 3D knn, 2D and 3D knn with maximum radius and <code>lookup</code> that is templated to allow queries within any kind of user-defined shapes. The source code of many <code>lidR</code> functions such as <a href="https://github.com/Jean-Romain/lidR/blob/20893dd0d737394c876bd8238b3a88ad6141ea62/src/LAS.cpp#L360">lmf()</a> or <a href="https://github.com/Jean-Romain/lidR/blob/20893dd0d737394c876bd8238b3a88ad6141ea62/src/LAS.cpp#L649">detect_shape()</a> might be useful resources as well.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="spatial-index.html#cb15-1"></a>SpatialIndex(<span class="at">const</span> Rcpp::S4 las);</span>
<span id="cb15-2"><a href="spatial-index.html#cb15-2"></a>SpatialIndex(<span class="at">const</span> Rcpp::S4 las, <span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">bool</span>&gt;&amp; filter);</span>
<span id="cb15-3"><a href="spatial-index.html#cb15-3"></a><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; <span class="dt">void</span> lookup(T&amp; shape, <span class="bu">std::</span>vector&lt;PointXYZ&gt;&amp; res);</span>
<span id="cb15-4"><a href="spatial-index.html#cb15-4"></a><span class="dt">void</span> knn(<span class="at">const</span> PointXY&amp; p, <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> k, <span class="bu">std::</span>vector&lt;PointXYZ&gt;&amp; res);</span>
<span id="cb15-5"><a href="spatial-index.html#cb15-5"></a><span class="dt">void</span> knn(<span class="at">const</span> PointXYZ&amp; p, <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> k, <span class="bu">std::</span>vector&lt;PointXYZ&gt;&amp; res);</span>
<span id="cb15-6"><a href="spatial-index.html#cb15-6"></a><span class="dt">void</span> knn(<span class="at">const</span> PointXY&amp; p, <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> k, <span class="at">const</span> <span class="dt">double</span> r, <span class="bu">std::</span>vector&lt;PointXYZ&gt;&amp; res);</span>
<span id="cb15-7"><a href="spatial-index.html#cb15-7"></a><span class="dt">void</span> knn(<span class="at">const</span> PointXYZ&amp; p, <span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> k, <span class="at">const</span> <span class="dt">double</span> r, <span class="bu">std::</span>vector&lt;PointXYZ&gt;&amp; res);</span></code></pre></div>
</div>
<div id="benchmark" class="section level3">
<h3><span class="header-section-number">18.2.4</span> Benchmark</h3>
<p>The lidR’s spatial index framework performs fast especially when large point clouds are implied. In the following we are comparing how fast <code>lidR</code> searches for the 10-nearest neighbours of every points of an ALS point-cloud with 2.3 millions points relatively to the <code>RANN</code>, <code>FANN</code> and <code>nabor</code> packages. We can see that it is competitive with the very fast <code>libnabo</code> library but does more than <code>libnabo</code> since it also performs geometrical queries such as point in discs, rectangles, cylinders, triangles, polygons. We don’t know any R library providing such capability to produce benchmark comparisons. Moreover lidR exposes the C++ classes to allow building efficient third party applications. This is for example heavily used in the <a href="https://github.com/Jean-Romain/lidRplugins">lidRplugins</a> package.</p>
<p><img src="lidR-book_files/figure-html/bench-knn-1.png" width="480" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="spatial-index-for-las-files" class="section level2">
<h2><span class="header-section-number">18.3</span> Spatial index for LAS files</h2>
<p>Previous sections were dedicated at explaining spatial index for <code>LAS</code> object i.e. point-clouds read with <code>readLAS()</code> and loaded in memory. This section focuses on spatial indexing for LAS files i.e. point-clouds stored in las/laz files and not (yet) loaded in memory. The problem of spatial queries at read time is the same but the solution is different because it was developed in an independent context.</p>
<p>Fast spatial queries are made possible by indexing the las or laz files with lax files. A lax file is a tiny file associated with a las or laz file that spatially indexes the points. This file type was created by Martin Isenburg in <a href="https://rapidlasso.com/">LAStools</a>. For a better understanding of how it works one can refer to a talk given by Martin Isenburg about <a href="https://rapidlasso.com/2012/12/03/lasindex-spatial-indexing-of-lidar-data/">lasindex</a>. In short it uses quadtree.</p>
<p>By adding lax files along with your las/laz files it is possible to make fast 2D queries <strong>without reading the whole file</strong>. The best way to create a lax file is to use <a href="https://www.cs.unc.edu/~isenburg/lastools/download/lasindex_README.txt">laxindex</a> from <a href="https://rapidlasso.com/lastools/">LAStools</a>. It is a free and open-source part of LAStools. If you cannot or do not want to use LAStools the <code>rlas</code> package has a function to creates lax files but <code>lasindex</code> should be preferred.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="spatial-index.html#cb16-1"></a>rlas<span class="op">::</span><span class="kw">writelax</span>(<span class="st">&quot;file.las&quot;</span>)</span></code></pre></div>
<p>The gain is really significant and transparent for users. If you have a lax file it will be used. That’s it. Let make a test with 150 queries from the same indexed and a non indexed <code>LAScatalog</code> with 400 files:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="spatial-index.html#cb17-1"></a>indexed =<span class="st"> </span><span class="kw">readLAScatalog</span>(<span class="st">&quot;LiDAR with lax/&quot;</span>)</span>
<span id="cb17-2"><a href="spatial-index.html#cb17-2"></a>noindex =<span class="st"> </span><span class="kw">readLAScatalog</span>(<span class="st">&quot;LiDAR no lax/&quot;</span>)</span>
<span id="cb17-3"><a href="spatial-index.html#cb17-3"></a></span>
<span id="cb17-4"><a href="spatial-index.html#cb17-4"></a><span class="kw">clip_circle</span>(indexed, xc, yc, <span class="dt">radius =</span> <span class="dv">12</span>)</span>
<span id="cb17-5"><a href="spatial-index.html#cb17-5"></a><span class="co">#&gt; 45 sec</span></span>
<span id="cb17-6"><a href="spatial-index.html#cb17-6"></a><span class="kw">clip_circle</span>(noindex, xc, yc, <span class="dt">radius =</span> <span class="dv">12</span>)</span>
<span id="cb17-7"><a href="spatial-index.html#cb17-7"></a><span class="co">#&gt; 4 sec</span></span></code></pre></div>
<p>If the reader did not skip the section “C++ API” of this chapter they might have noticed that <code>clip_circle()</code> can use a spatial index with a <code>LAScatalog</code> but not with a <code>LAS</code>. This is because they behave internally very differently and rely on two independent mechanisms. With a <code>LAScatalog</code> it inherits of the capabilities of the library used to read the file while with a <code>LAS</code> nothing has been implemented (yet) for taking advantage of spatial indexing at the R level (but the section above provide the solution).</p>
<p>It is easy to guess that every <code>clip_something()</code> functions can take advantage of spatial indexing with lax files but the LAScatalog processing engine also makes an heavy usage of such feature. Users can significantly reduce the processing time by loading a buffer faster. Indeed loading a buffer implies spatial queries. This topic is covered by the vignette: <a href="https://cran.r-project.org/web/packages/lidR/vignettes/lidR-computation-speed-LAScatalog.html">Speed-up the computations on a LAScatalog</a>.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="outbox.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="plugins.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>

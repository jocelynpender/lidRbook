[["spatial-indexing.html", "18 Spatial indexes 18.1 Introduction to spatial indexes 18.2 Spatial indexes for LAS objects 18.3 Spatial index for LAS files", " 18 Spatial indexes Spatial index is one key features for performing spatial queries in a large point-cloud. Without indexing, any search for points of interest would require a “sequential scan” of every points. Indexing speeds up searching by organizing the data into a search structure which can be quickly traversed to find particular records. Some algorithms could simply not work in a reasonable time-frame without spatial indexing. 18.1 Introduction to spatial indexes This section presents an overview, with simple words, of how spatial indexes works. If the reader is already knowledgeable about spatial indexing, they can skip this section which only skim over the concept of spatial index. Imagine that with have 1,000,000 points (which is not a lot). We want to query all the points that belong in a disc centred on p(300, 350) with a radius of 25 meters. This is a typical query made thousands of times per second by many algorithms such as the local maximum filter used to locate individual trees. Without spatial index, the method consists in computing the distance to p for every single point. This is called ‘sequential scan’ and it requires to computes 1,000,000 times the distance and perform 1,000,000 comparisons for a point cloud with 1,000,000 points. In R we can write: p = c(300, 350) R = 25 X = runif(1e4, 0, 1000) Y = runif(1e4, 0, 1000) query = sqrt((X - p[1])^2 + (Y - p[2])^2) &lt; R Xq = X[query] Yq = Y[query] This is typically what the function filter_poi() does because filter_poi() is not a specialized function and enables to query any kind of points of interest (POI) including non spatial queries such as Intensity &gt; x. filter_poi(las, sqrt((X - p[1])^2 + (Y - p[2])^2) &lt; R) Now imagine we want to perform 1,000,000 queries like that for 1,000,000 different points p. It means that we need to perform 1,000,000 x 1,000,000 = 1 billion operations. We say that it has a quadratic complexity. This does not scale-up and quickly becomes not computable (or at least dramatically slow). With a spatial index the points are organized in such a way that the computer does not need to perform all the comparisons. In a quadtree, for example, the points are subdivided in 4 quadrants that are themselves subdivided in four quadrants and so on hierachically (see figure below). In that cases we can exclude 75% of the points (750,000 points) in 4 operations at the top level (in red). The bounding box of our query being [275,325]x[325,375] we know that the POIs do not belong in top-left quadrant ([0,500] x [500,1000]) nor in top-right quadrant ([500,1000] x [500,1000]) nor in bottom-right quadrant. At the second level (in blue) in 4 more operations we can exclude another 75% of the remaining points to search only in one quadrant. At this stage we can perform a sequential scan on only 1/16th of the points (i.e. 62,500 points) meaning that we discarded 937,500 points in 8 operations. Consequently our query is (roughly) 16 times faster. With more subdivision levels it is even faster. In lidR a typical quadtree has 8 levels i.e. the space is subdivided in (28)2 = 65536 quadrants. Spatial indexing provides a way to dramatically speed-up many common operations that require to perform spatial queries either in disc, rectangle, polygons, 2D, 3D and so on. It exists different types of spatial indexes for different purposes but in all case the uses of a spatial index is not free and comes at the cost of a greater memory usage. 18.2 Spatial indexes for LAS objects 18.2.1 Overview lidR makes use of spatial indexes in many functions and can choose different types of spatial indexes on-the-fly. So far, the book only presented the function readLAS() (see chapter 2) but the package has some variations of readLAS() named readALSLAS(), readTLSLAS(), readUAVLAS() and so on that enables to register a point-cloud type allowing lidR to adequately choose the most appropriated spatial index method to perform a given computation as fast as possible. As an example we can use the TLS point-cloud pine_plot.laz from the TreeLS package. First we read it with readLAS(). In that case the point-cloud is considered as ALS because lidR was originally designed for ALS and by legacy readLAS() from version &lt;= 3.1 behaves optimally for ALS. In the second case we use readTLSLAS() to inform lidR that this point cloud was sampled with a terrestrial device. In the following test, the computation time dropped from ~2.5 sec to ~1.3 sec by registering the proper point type. Improvements may range from 2 to 10 times faster depending on the point cloud and the method used. file &lt;- system.file(&quot;extdata&quot;, &quot;pine_plot.laz&quot;, package=&quot;TreeLS&quot;) las &lt;- readLAS(file, select=&#39;xyz&#39;) tls &lt;- readTLSLAS(file, select=&#39;xyz&#39;) system.time(segment_shapes(las, shp_plane(k = 15), &quot;Coplanar&quot;)) #&gt; user system elapsed #&gt; 2.534 0.000 1.340 system.time(segment_shapes(tls, shp_plane(k = 15), &quot;Coplanar&quot;)) #&gt; user system elapsed #&gt; 1.136 0.004 0.588 This works for each method that implies many sequential spatial queries. In the following example we can observe a ~8 fold speed-up. system.time(point_metrics(las, r = 1, ~length(Z))) #&gt; user system elapsed #&gt; 9.740 0.016 9.759 system.time(point_metrics(tls, r = 1, ~length(Z))) #&gt; user system elapsed #&gt; 1.236 0.000 1.236 Let now try with an ALS point-cloud. We can observe that it is better to read and ALS point-cloud as ALS rather than as TLS (2 fold difference). This is because registering the correct point-cloud type enables to optimally select an appropriated spatial index internally. als = readALSLAS(&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;) tls = readTLSLAS(&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;) system.time(classify_noise(als, sor())) #&gt; user system elapsed #&gt; 4.285 0.000 2.222 system.time(classify_noise(tls, sor())) #&gt; user system elapsed #&gt; 7.898 0.036 4.060 As a conclusion it is always a good idea to use the new functions readALSLAS(), readTLSLAS(), readDAPLAS(), and so on introduced in lidR v3.1.0. However reading the point-cloud with the correct read*LAS() function does not always guarantee to get the optimal performance. First, all the functions do not use spatial indexing or do not use the spatial index framework of lidR. This is the case of the kriging() function, for example, that is based on the gstat package. Second the choice of the spatial index relies on some assumptions that may not be met in some specific point-clouds. The internal dispatch is designed to work with ‘typical’ point-cloud under some assumptions. An ALS point-cloud is typically spatially large (1 km² or more) with little Z dispersion (0 to 40 meters) relatively to the XY dispersion (0 to 1000 meters). On the contrary an TLS point cloud is typically spatially narrow (3000 m²) with proportionally a lot a variations on Z relatively to XY. read*LAS() should be sufficient for most use cases but for some specific cases users can manually choose which spatial index suit best and this is the topic of the next section. 18.2.2 Spatial indexes and selection strategies lidR currently has 4 spatial indexes: a grid partition, a voxel partition, a quadtree and an octree. Each having pros and cons. grid partition and quadtree are 2D indexes while voxel partition and octree are 3D indexes. They are all able to perform any kind of spatial query similarly. This is why it does not matter if the point-cloud is read with readALSLAS() or readTLSLAS(). The result will be the same. However their efficiency dependent on the point-cloud type and the query type. This is why using the proper read function can matter. The following rules allow to select the best index. For ALS we use a 2D index even for 3D queries. Indeed an ALS point-cloud is ‘mostly 2D’ because more than 99% of the dispersion is on XY. When querying the knn of a given point (3D query) from a 2D index the vast majority of the points are discarded on a 2D base. The remaining sequential scan occurs only on a very tiny fraction of the dataset. This is also true for a 3D index but querying a 3D spatial index is slower and thus in lidR our 2D indexes perform best for ALS. A grid partition is used by default because it is faster than a quadtree in most cases because in ALS points are uniformly distributed on XY. The following example demonstrates how to manually register a spatial index and compare the computation times for a quadtree and an octree. las = readLAS(&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;, select = &quot;xyz&quot;) index(las) &lt;- &quot;quadtree&quot; system.time(classify_noise(las, sor())) #&gt; user system elapsed #&gt; 4.003 0.000 2.087 index(las) &lt;- &quot;octree&quot; system.time(classify_noise(las, sor())) #&gt; user system elapsed #&gt; 10.468 0.052 5.436 For TLS we use a 3D index because in this case the point are almost evenly distributed in XYZ and thus a 2D query does not allow for discarding a large fraction of the points and the sequential scan part remains important. An octree is used because points are expected to be not uniformly distributed on XYZ. file &lt;- system.file(&quot;extdata&quot;, &quot;pine_plot.laz&quot;, package=&quot;TreeLS&quot;) las &lt;- readLAS(file, select=&#39;xyz&#39;) index(las) &lt;- &quot;quadtree&quot; system.time(classify_noise(las, sor())) #&gt; user system elapsed #&gt; 1.599 0.004 0.866 index(las) &lt;- &quot;octree&quot; system.time(classify_noise(las, sor())) #&gt; user system elapsed #&gt; 0.549 0.000 0.312 For DAP and UAV we apply the same rules. When encountering a dataset that do not follow these rules it may be clever to manually select a spatial index. This is the case of the dataset seen in chapter 13.2.1 which is an ALS dataset but in practice it is a small subset in which we can no longer say that more than 99% of the point dispersion is on XY only. In that sense it is more a TLS-ish point-cloud. But in the meantime the points are uniformly spread on XY because it is actually an ALS dataset. Thus making 3D queries in a 3D index is maybe more clever. Let’s try out: las &lt;- readLAS(&quot;data/chap11/building_WilliamsAZ_Urban_normalized.laz&quot;) index(las) &lt;- &quot;gridpartition&quot; system.time(segment_shapes(las, shp_plane(k = 20), &quot;planar&quot;, filter = ~Classification != LASGROUND)) #&gt; user system elapsed #&gt; 2.979 0.004 1.538 index(las) &lt;- &quot;voxelpartition&quot; system.time(segment_shapes(las, shp_plane(k = 20), &quot;planar&quot;, filter = ~Classification != LASGROUND)) #&gt; user system elapsed #&gt; 3.136 0.000 1.627 Here both are almost equal and “octree” is slower. But one may find limit cases where it worth it to perform manual selection and thus lidR allows for overwriting the default rules. More details in help(\"lidR-spatial-index\"). 18.2.3 C++ API For more advanced users and developers the lidR’s spatial index framework is provided as header-only C++ classes meaning that users can link to lidR to develop R/C++ applications using lidR spatial indexes. If the reader is not comfortable with the terms C++, Rcpp, header-only, external pointer and other C++ related concepts, all right, you can skip this section which is more dedicated to advanced users and package developers who want to develop complex and efficient tools but it does not bring much for regular users. For the purpose of this example we will create a function clip_disc() similar to clip_circle() available in lidR. clip_circle() performs sequential scan and is thus not suitable to perform many queries in a loop for example. The function clip_disc() on the contrary will take advantage of spatial indexing. There is only one C++ class to know named SpatialIndex. It has one constructor that accepts an S4 class and has two public members knn and lookup. First we can write a C++ function that returns a pointer on a SpatialIndex. Here we are using an external pointer because it is simple to write and implies fewer lines of code but we can also imagine taking advantage of Rcpp modules. // [[Rcpp::depends(lidR)]] #include &lt;SpatialIndex.h&gt; using namespace Rcpp; using namespace lidR; // [[Rcpp::export]] XPtr&lt;SpatialIndex&gt; spatial_index(S4 las) { SpatialIndex* idx = new SpatialIndex(las); XPtr&lt;SpatialIndex&gt; p(idx, true); return p; Now we can instantiate a SpatialIndex at R level las = readLAS(&quot;data/ENGINE/catalog/tiles_338000_5238500_1.laz&quot;) index = spatial_index(las) index #&gt; &lt;pointer: 0x562e8af88360&gt; What has been created here is either a grid partition, a voxel partition, a quadtree or an octree depending on which readLAS() function was used to read the files or depending on the spatial index that was manually registered. Then we can write the C++ side of the query. // [[Rcpp::export]] IntegerVector filter_disc_with_index(SEXP xptr, double xc, double yc, double r) { XPtr&lt;SpatialIndex&gt; tree(xptr); Circle circ(xc, yc, r); std::vector&lt;PointXYZ&gt; pts; tree-&gt;lookup(circ, pts); IntegerVector ids(pts.size()); for(int i = 0 ; i &lt; pts.size(); i++) { ids[i] = pts[i].id; } return ids + 1; // C++ is 0-indexed } And the R side of the query clip_disc = function(las, index, xcenter, ycenter, radius) { ii &lt;- filter_disc_with_index(index, xcenter, ycenter, radius) return(las[ii]) } Now we can make a query a verify that both functions return the same points. sub1 = clip_disc(las, index, 338200, 5238585, 10) sub2 = clip_circle(las, 338200, 5238585, 10) sub1 #&gt; class : LAS (v1.0 format 1) #&gt; memory : 109.1 Kb #&gt; extent : 338190, 338209.9, 5238575, 5238595 (xmin, xmax, ymin, ymax) #&gt; coord. ref. : WGS 84 / UTM zone 19N #&gt; area : 305.4827 m² #&gt; points : 1.1 thousand points #&gt; density : 3.75 points/m² sub2 #&gt; class : LAS (v1.0 format 1) #&gt; memory : 109.1 Kb #&gt; extent : 338190, 338209.9, 5238575, 5238595 (xmin, xmax, ymin, ymax) #&gt; coord. ref. : WGS 84 / UTM zone 19N #&gt; area : 305.4827 m² #&gt; points : 1.1 thousand points #&gt; density : 3.75 points/m² While there is no gain with a single query because of the overhead of creating an index, it is indispensable to perform many successive queries. In the following we perform 50 queries in a loop. n = 50 x = runif(n, 338000, 338500) y = runif(n, 5238500, 5239000) system.time(for (i in 1:n) u = clip_circle(las, x[i], y[i], 10)) #&gt; user system elapsed #&gt; 2.847 0.160 2.940 system.time(for (i in 1:n) u = clip_disc(las, index, x[i], y[i], 10)) #&gt; user system elapsed #&gt; 0.295 0.024 0.209 For more functionalities one can look at the source code of SpatialIndex where we can see there are actually 2 constructors and 5 members including 2D and 3D knn, 2D and 3D knn with maximum radius and lookup that is templated to allow queries within any kind of user-defined shapes. The source code of many lidR functions such as lmf() or detect_shape() might be useful resources as well. SpatialIndex(const Rcpp::S4 las); SpatialIndex(const Rcpp::S4 las, const std::vector&lt;bool&gt;&amp; filter); template&lt;typename T&gt; void lookup(T&amp; shape, std::vector&lt;PointXYZ&gt;&amp; res); void knn(const PointXY&amp; p, const unsigned int k, std::vector&lt;PointXYZ&gt;&amp; res); void knn(const PointXYZ&amp; p, const unsigned int k, std::vector&lt;PointXYZ&gt;&amp; res); void knn(const PointXY&amp; p, const unsigned int k, const double r, std::vector&lt;PointXYZ&gt;&amp; res); void knn(const PointXYZ&amp; p, const unsigned int k, const double r, std::vector&lt;PointXYZ&gt;&amp; res); 18.2.4 Benchmark The lidR’s spatial index framework performs fast especially when large point clouds are implied. In the following we are comparing how fast lidR searches for the 10-nearest neighbours of every points of an ALS point-cloud with 2.3 millions points relatively to the RANN, FANN and nabor packages. We can see that it is competitive with the very fast libnabo library but does more than libnabo since it also performs geometrical queries such as point in discs, rectangles, cylinders, triangles, polygons. We don’t know any R library providing such capability to produce benchmark comparisons. Moreover lidR exposes the C++ classes to allow building efficient third party applications. This is for example heavily used in the lidRplugins package. 18.3 Spatial index for LAS files Previous sections were dedicated at explaining spatial index for LAS object i.e. point-clouds read with readLAS() and loaded in memory. This section focuses on spatial indexing for LAS files i.e. point-clouds stored in las/laz files and not (yet) loaded in memory. The problem of spatial queries at read time is the same but the solution is different because it was developed in an independent context. Fast spatial queries are made possible by indexing the las or laz files with lax files. A lax file is a tiny file associated with a las or laz file that spatially indexes the points. This file type was created by Martin Isenburg in LAStools. For a better understanding of how it works one can refer to a talk given by Martin Isenburg about lasindex. In short it uses quadtree. By adding lax files along with your las/laz files it is possible to make fast 2D queries without reading the whole file. The best way to create a lax file is to use laxindex from LAStools. It is a free and open-source part of LAStools. If you cannot or do not want to use LAStools the rlas package has a function to creates lax files but lasindex should be preferred. rlas::writelax(&quot;file.las&quot;) The gain is really significant and transparent for users. If you have a lax file it will be used. That’s it. Let make a test with 150 queries from the same indexed and a non indexed LAScatalog with 400 files: indexed = readLAScatalog(&quot;LiDAR with lax/&quot;) noindex = readLAScatalog(&quot;LiDAR no lax/&quot;) clip_circle(indexed, xc, yc, radius = 12) #&gt; 45 sec clip_circle(noindex, xc, yc, radius = 12) #&gt; 4 sec If the reader did not skip the section “C++ API” of this chapter they might have noticed that clip_circle() can use a spatial index with a LAScatalog but not with a LAS. This is because they behave internally very differently and rely on two independent mechanisms. With a LAScatalog it inherits of the capabilities of the library used to read the file while with a LAS nothing has been implemented (yet) for taking advantage of spatial indexing at the R level (but the section above provide the solution). It is easy to guess that every clip_something() functions can take advantage of spatial indexing with lax files but the LAScatalog processing engine also makes an heavy usage of such feature. Users can significantly reduce the processing time by loading a buffer faster. Indeed loading a buffer implies spatial queries. This topic is covered by the vignette: Speed-up the computations on a LAScatalog. "]]
